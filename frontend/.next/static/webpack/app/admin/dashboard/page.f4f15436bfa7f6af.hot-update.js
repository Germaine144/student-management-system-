"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/admin/dashboard/page",{

/***/ "(app-pages-browser)/./src/lib/api.ts":
/*!************************!*\
  !*** ./src/lib/api.ts ***!
  \************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   changeUserRole: () => (/* binding */ changeUserRole),\n/* harmony export */   createStudent: () => (/* binding */ createStudent),\n/* harmony export */   deleteStudent: () => (/* binding */ deleteStudent),\n/* harmony export */   getAdminDashboardStats: () => (/* binding */ getAdminDashboardStats),\n/* harmony export */   getAllStudents: () => (/* binding */ getAllStudents),\n/* harmony export */   getMyProfile: () => (/* binding */ getMyProfile),\n/* harmony export */   getUserProfile: () => (/* binding */ getUserProfile),\n/* harmony export */   loginUser: () => (/* binding */ loginUser),\n/* harmony export */   registerUser: () => (/* binding */ registerUser),\n/* harmony export */   updateMyProfile: () => (/* binding */ updateMyProfile),\n/* harmony export */   updateStudent: () => (/* binding */ updateStudent),\n/* harmony export */   updateUserProfile: () => (/* binding */ updateUserProfile)\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/../node_modules/axios/lib/axios.js\");\n\n// Simulate network delay for realism\nconst delay = (ms)=>new Promise((resolve)=>setTimeout(resolve, ms));\n// =====================================\n// === MOCKED DATABASE (SOURCE OF TRUTH)\n// =====================================\nlet mockUsersDb = [\n    {\n        id: 'admin-01',\n        name: 'Admin User',\n        email: 'admin@test.com',\n        role: 'admin',\n        phone: '123-456-7890'\n    },\n    {\n        id: 'student-01',\n        name: 'Student User',\n        email: 'student@test.com',\n        role: 'student',\n        phone: '098-765-4321',\n        course: 'Computer Science',\n        enrollmentYear: 2022\n    },\n    {\n        id: 's1',\n        name: 'Alice Johnson',\n        email: 'alice@test.com',\n        role: 'student',\n        phone: '111-222-3333',\n        course: 'Web Development',\n        enrollmentYear: 2023\n    },\n    {\n        id: 's2',\n        name: 'Bob Williams',\n        email: 'bob@test.com',\n        role: 'student',\n        phone: '444-555-6666',\n        course: 'Data Science',\n        enrollmentYear: 2022\n    },\n    {\n        id: 's3',\n        name: 'Charlie Brown',\n        email: 'charlie@test.com',\n        role: 'student',\n        phone: '777-888-9999',\n        course: 'UX/UI Design',\n        enrollmentYear: 2023\n    },\n    {\n        id: 's4',\n        name: 'Diana Prince',\n        email: 'diana@test.com',\n        role: 'student',\n        phone: '121-232-3434',\n        course: 'Data Science',\n        enrollmentYear: 2024\n    }\n];\n// ============================================\n// === UTILITY FUNCTION: StudentRecord Mapping\n// ============================================\nconst getStudentRecords = ()=>{\n    return mockUsersDb.filter((user)=>user.role === 'student').map((user)=>({\n            id: user.id,\n            name: user.name,\n            email: user.email,\n            course: user.course || 'N/A',\n            enrollmentYear: user.enrollmentYear || 0,\n            status: user.enrollmentYear && user.enrollmentYear < 2023 ? 'Graduated' : 'Active'\n        }));\n};\n// ==============================\n// === AUTHENTICATION\n// ==============================\n// === LOGIN USER\n/**\n * Logs in a user by sending their credentials to the backend.\n * On success, returns a user profile and JWT token.\n */ const loginUser = async (email, password)=>{\n    try {\n        const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].post(\"\".concat(\"http://localhost:5001\", \"/api/auth/login\"), {\n            email,\n            password\n        });\n        const { user, token } = response.data;\n        // Map backend's fullName to frontend's expected 'name'\n        const formattedUser = {\n            id: user.id,\n            name: user.fullName,\n            email: user.email,\n            role: user.role,\n            phone: user.phone,\n            profilePicture: user.profilePicture,\n            course: user.course,\n            enrollmentYear: user.enrollmentYear,\n            joinedAt: user.joinedAt || user.createdAt\n        };\n        return {\n            user: formattedUser,\n            token\n        };\n    } catch (error) {\n        var _error_response_data, _error_response;\n        const message = (error === null || error === void 0 ? void 0 : (_error_response = error.response) === null || _error_response === void 0 ? void 0 : (_error_response_data = _error_response.data) === null || _error_response_data === void 0 ? void 0 : _error_response_data.message) || 'Login failed';\n        throw new Error(message);\n    }\n};\n// === REGISTER USER\nconst BASE_URL = \"http://localhost:5001\";\nconst registerUser = async (userData)=>{\n    try {\n        const url = \"\".concat(BASE_URL, \"/api/auth/register\");\n        console.log(\"ðŸ‘‰ Full Registration URL:\", url); // ðŸ‘ˆ print this!\n        const res = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].post(url, {\n            fullName: userData.name,\n            email: userData.email,\n            password: userData.password,\n            phone: userData.phone,\n            course: userData.course,\n            role: userData.role || 'student'\n        }, {\n            withCredentials: true\n        });\n        return res.data.user;\n    } catch (error) {\n        var _error_response_data, _error_response;\n        console.error(\"Registration error:\", error); // ðŸ‘ˆ log entire error\n        throw new Error((error === null || error === void 0 ? void 0 : (_error_response = error.response) === null || _error_response === void 0 ? void 0 : (_error_response_data = _error_response.data) === null || _error_response_data === void 0 ? void 0 : _error_response_data.message) || 'Registration failed. Please try again.');\n    }\n};\n// === THE USER\nconst getUserProfile = async (token)=>{\n    await delay(300);\n    const userId = token.replace('mock-jwt-for-', '');\n    const user = mockUsersDb.find((u)=>u.id === userId);\n    if (!user) throw new Error(\"User not found\");\n    return user;\n};\nconst updateUserProfile = async (userId, profileData, token)=>{\n    await delay(500);\n    if (!token.includes('mock-jwt-for-')) throw new Error(\"Unauthorized access\");\n    const userIndex = mockUsersDb.findIndex((u)=>u.id === userId);\n    if (userIndex === -1) throw new Error(\"User not found for update\");\n    Object.assign(mockUsersDb[userIndex], profileData);\n    return mockUsersDb[userIndex];\n};\nconst getAllStudents = async function(token) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    await delay(800);\n    if (!token.includes('admin')) throw new Error(\"Unauthorized access\");\n    const { page = 1, limit = 5, statusFilter = 'All' } = options;\n    let allStudents = getStudentRecords();\n    if (statusFilter !== 'All') {\n        allStudents = allStudents.filter((s)=>s.status === statusFilter);\n    }\n    const total = allStudents.length;\n    const paginatedStudents = allStudents.slice((page - 1) * limit, page * limit);\n    return {\n        students: paginatedStudents,\n        total\n    };\n};\nconst createStudent = async (studentData, token)=>{\n    await delay(500);\n    if (!token.includes('admin')) throw new Error(\"Unauthorized access\");\n    if (mockUsersDb.some((user)=>user.email === studentData.email)) {\n        throw new Error('A student with this email already exists.');\n    }\n    const newUser = {\n        id: \"user-\".concat(Date.now()),\n        name: studentData.name,\n        email: studentData.email,\n        role: 'student',\n        course: studentData.course,\n        enrollmentYear: studentData.enrollmentYear\n    };\n    mockUsersDb.push(newUser);\n    return newUser;\n};\nconst updateStudent = async (id, studentData, token)=>{\n    await delay(500);\n    if (!token.includes('admin')) throw new Error(\"Unauthorized access\");\n    const userIndex = mockUsersDb.findIndex((u)=>u.id === id);\n    if (userIndex === -1) throw new Error(\"User not found for update\");\n    Object.assign(mockUsersDb[userIndex], studentData);\n    return mockUsersDb[userIndex];\n};\nconst deleteStudent = async (id, token)=>{\n    await delay(500);\n    if (!token.includes('admin')) throw new Error(\"Unauthorized access\");\n    mockUsersDb = mockUsersDb.filter((u)=>u.id !== id);\n};\nconst changeUserRole = async (userId, newRole, token)=>{\n    await delay(500);\n    if (!token.includes('admin')) throw new Error(\"Unauthorized access\");\n    const userIndex = mockUsersDb.findIndex((u)=>u.id === userId);\n    if (userIndex === -1) throw new Error(\"User not found for role change\");\n    mockUsersDb[userIndex].role = newRole;\n    return mockUsersDb[userIndex];\n};\n// ==============================\n// === USER PROFILE & DASHBOARD\n// ==============================\nconst getAdminDashboardStats = async (token)=>{\n    await delay(400);\n    if (!token.includes('admin')) throw new Error(\"Unauthorized access\");\n    const allStudents = getStudentRecords();\n    return {\n        total: allStudents.length,\n        active: allStudents.filter((s)=>s.status === 'Active').length,\n        graduated: allStudents.filter((s)=>s.status === 'Graduated').length\n    };\n};\nconst getMyProfile = async (accessToken)=>{\n    const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].get(\"\".concat(\"http://localhost:5001\", \"/api/auth/me\"), {\n        headers: {\n            Authorization: \"Bearer \".concat(accessToken)\n        }\n    });\n    const user = response.data;\n    return {\n        id: user.id,\n        name: user.fullName,\n        email: user.email,\n        phone: user.phone,\n        role: user.role,\n        course: user.course,\n        enrollmentYear: user.enrollmentYear,\n        joinedAt: user.createdAt || user.joinedAt\n    };\n};\nconst updateMyProfile = async (profileData, token)=>{\n    const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].put(\"\".concat(\"http://localhost:5001\", \"/api/users/me\"), profileData, {\n        headers: {\n            Authorization: \"Bearer \".concat(token)\n        }\n    });\n    const user = response.data;\n    return {\n        id: user.id,\n        name: user.fullName,\n        email: user.email,\n        phone: user.phone,\n        role: user.role,\n        course: user.course,\n        enrollmentYear: user.enrollmentYear,\n        joinedAt: user.createdAt || user.joinedAt\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QkQsTUFBTU0sS0FBS04sSUFBSTtRQUNmRSxRQUFRSSxLQUFLSixNQUFNO1FBQ25CQyxnQkFBZ0JHLEtBQUtILGNBQWM7UUFDbkNrQixVQUFVZixLQUFLZ0IsU0FBUyxJQUFJaEIsS0FBS2UsUUFBUTtJQUMzQztBQUNGLEVBQUU7QUFFSyxNQUFNd0Qsa0JBQWtCLE9BQzdCckMsYUFDQXhCO0lBRUEsTUFBTUwsV0FBVyxNQUFNckIsNkNBQUtBLENBQUN3RixHQUFHLENBQzlCLEdBQXVDLE9BQXBDakUsdUJBQW1DLEVBQUMsa0JBQ3ZDMkIsYUFDQTtRQUNFbUMsU0FBUztZQUNQQyxlQUFlLFVBQWdCLE9BQU41RDtRQUMzQjtJQUNGO0lBR0YsTUFBTVYsT0FBT0ssU0FBU00sSUFBSTtJQUUxQixPQUFPO1FBQ0xwQixJQUFJUyxLQUFLVCxFQUFFO1FBQ1hDLE1BQU1RLEtBQUthLFFBQVE7UUFDbkJwQixPQUFPTyxLQUFLUCxLQUFLO1FBQ2pCRSxPQUFPSyxLQUFLTCxLQUFLO1FBQ2pCRCxNQUFNTSxLQUFLTixJQUFJO1FBQ2ZFLFFBQVFJLEtBQUtKLE1BQU07UUFDbkJDLGdCQUFnQkcsS0FBS0gsY0FBYztRQUNuQ2tCLFVBQVVmLEtBQUtnQixTQUFTLElBQUloQixLQUFLZSxRQUFRO0lBQzNDO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsiL1VzZXJzL3lvdW5nc2F2YWdlL3N0dWRlbnQtbWFuYWdlbWVudC1zeXN0ZW0tL2Zyb250ZW5kL3NyYy9saWIvYXBpLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEF1dGhSZXNwb25zZSwgU3R1ZGVudFJlY29yZCwgVXNlclByb2ZpbGUgfSBmcm9tIFwiQC90eXBlc1wiO1xuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcblxuLy8gU2ltdWxhdGUgbmV0d29yayBkZWxheSBmb3IgcmVhbGlzbVxuY29uc3QgZGVsYXkgPSAobXM6IG51bWJlcikgPT4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vID09PSBNT0NLRUQgREFUQUJBU0UgKFNPVVJDRSBPRiBUUlVUSClcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxubGV0IG1vY2tVc2Vyc0RiOiBVc2VyUHJvZmlsZVtdID0gW1xuICB7IGlkOiAnYWRtaW4tMDEnLCBuYW1lOiAnQWRtaW4gVXNlcicsIGVtYWlsOiAnYWRtaW5AdGVzdC5jb20nLCByb2xlOiAnYWRtaW4nLCBwaG9uZTogJzEyMy00NTYtNzg5MCcgfSxcbiAgeyBpZDogJ3N0dWRlbnQtMDEnLCBuYW1lOiAnU3R1ZGVudCBVc2VyJywgZW1haWw6ICdzdHVkZW50QHRlc3QuY29tJywgcm9sZTogJ3N0dWRlbnQnLCBwaG9uZTogJzA5OC03NjUtNDMyMScsIGNvdXJzZTogJ0NvbXB1dGVyIFNjaWVuY2UnLCBlbnJvbGxtZW50WWVhcjogMjAyMiB9LFxuICB7IGlkOiAnczEnLCBuYW1lOiAnQWxpY2UgSm9obnNvbicsIGVtYWlsOiAnYWxpY2VAdGVzdC5jb20nLCByb2xlOiAnc3R1ZGVudCcsIHBob25lOiAnMTExLTIyMi0zMzMzJywgY291cnNlOiAnV2ViIERldmVsb3BtZW50JywgZW5yb2xsbWVudFllYXI6IDIwMjMgfSxcbiAgeyBpZDogJ3MyJywgbmFtZTogJ0JvYiBXaWxsaWFtcycsIGVtYWlsOiAnYm9iQHRlc3QuY29tJywgcm9sZTogJ3N0dWRlbnQnLCBwaG9uZTogJzQ0NC01NTUtNjY2NicsIGNvdXJzZTogJ0RhdGEgU2NpZW5jZScsIGVucm9sbG1lbnRZZWFyOiAyMDIyIH0sXG4gIHsgaWQ6ICdzMycsIG5hbWU6ICdDaGFybGllIEJyb3duJywgZW1haWw6ICdjaGFybGllQHRlc3QuY29tJywgcm9sZTogJ3N0dWRlbnQnLCBwaG9uZTogJzc3Ny04ODgtOTk5OScsIGNvdXJzZTogJ1VYL1VJIERlc2lnbicsIGVucm9sbG1lbnRZZWFyOiAyMDIzIH0sXG4gIHsgaWQ6ICdzNCcsIG5hbWU6ICdEaWFuYSBQcmluY2UnLCBlbWFpbDogJ2RpYW5hQHRlc3QuY29tJywgcm9sZTogJ3N0dWRlbnQnLCBwaG9uZTogJzEyMS0yMzItMzQzNCcsIGNvdXJzZTogJ0RhdGEgU2NpZW5jZScsIGVucm9sbG1lbnRZZWFyOiAyMDI0IH0sXG5dO1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gPT09IFVUSUxJVFkgRlVOQ1RJT046IFN0dWRlbnRSZWNvcmQgTWFwcGluZ1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuY29uc3QgZ2V0U3R1ZGVudFJlY29yZHMgPSAoKTogU3R1ZGVudFJlY29yZFtdID0+IHtcbiAgcmV0dXJuIG1vY2tVc2Vyc0RiXG4gICAgLmZpbHRlcih1c2VyID0+IHVzZXIucm9sZSA9PT0gJ3N0dWRlbnQnKVxuICAgIC5tYXAodXNlciA9PiAoe1xuICAgICAgaWQ6IHVzZXIuaWQsXG4gICAgICBuYW1lOiB1c2VyLm5hbWUsXG4gICAgICBlbWFpbDogdXNlci5lbWFpbCxcbiAgICAgIGNvdXJzZTogdXNlci5jb3Vyc2UgfHwgJ04vQScsXG4gICAgICBlbnJvbGxtZW50WWVhcjogdXNlci5lbnJvbGxtZW50WWVhciB8fCAwLFxuICAgICAgc3RhdHVzOiAodXNlci5lbnJvbGxtZW50WWVhciAmJiB1c2VyLmVucm9sbG1lbnRZZWFyIDwgMjAyMykgPyAnR3JhZHVhdGVkJyA6ICdBY3RpdmUnLFxuICAgIH0pKTtcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gPT09IEFVVEhFTlRJQ0FUSU9OXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLy8gPT09IExPR0lOIFVTRVJcblxuLyoqXG4gKiBMb2dzIGluIGEgdXNlciBieSBzZW5kaW5nIHRoZWlyIGNyZWRlbnRpYWxzIHRvIHRoZSBiYWNrZW5kLlxuICogT24gc3VjY2VzcywgcmV0dXJucyBhIHVzZXIgcHJvZmlsZSBhbmQgSldUIHRva2VuLlxuICovXG5leHBvcnQgY29uc3QgbG9naW5Vc2VyID0gYXN5bmMgKGVtYWlsOiBzdHJpbmcsIHBhc3N3b3JkOiBzdHJpbmcpOiBQcm9taXNlPEF1dGhSZXNwb25zZT4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MucG9zdChgJHtwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19CQUNLRU5EX1VSTH0vYXBpL2F1dGgvbG9naW5gLCB7XG4gICAgICBlbWFpbCxcbiAgICAgIHBhc3N3b3JkLFxuICAgIH0pO1xuXG4gICAgY29uc3QgeyB1c2VyLCB0b2tlbiB9ID0gcmVzcG9uc2UuZGF0YTtcblxuICAgIC8vIE1hcCBiYWNrZW5kJ3MgZnVsbE5hbWUgdG8gZnJvbnRlbmQncyBleHBlY3RlZCAnbmFtZSdcbiAgICBjb25zdCBmb3JtYXR0ZWRVc2VyOiBVc2VyUHJvZmlsZSA9IHtcbiAgICAgIGlkOiB1c2VyLmlkLFxuICAgICAgbmFtZTogdXNlci5mdWxsTmFtZSxcbiAgICAgIGVtYWlsOiB1c2VyLmVtYWlsLFxuICAgICAgcm9sZTogdXNlci5yb2xlLFxuICAgICAgcGhvbmU6IHVzZXIucGhvbmUsXG4gICAgICBwcm9maWxlUGljdHVyZTogdXNlci5wcm9maWxlUGljdHVyZSxcbiAgICAgIGNvdXJzZTogdXNlci5jb3Vyc2UsXG4gICAgICBlbnJvbGxtZW50WWVhcjogdXNlci5lbnJvbGxtZW50WWVhcixcbiAgICAgIGpvaW5lZEF0OiB1c2VyLmpvaW5lZEF0IHx8IHVzZXIuY3JlYXRlZEF0LCAvLyBzdXBwb3J0IGJvdGggaWYgbmVlZGVkXG4gICAgfTtcblxuICAgIHJldHVybiB7IHVzZXI6IGZvcm1hdHRlZFVzZXIsIHRva2VuIH07XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gZXJyb3I/LnJlc3BvbnNlPy5kYXRhPy5tZXNzYWdlIHx8ICdMb2dpbiBmYWlsZWQnO1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxufTtcblxuLy8gPT09IFJFR0lTVEVSIFVTRVJcbmNvbnN0IEJBU0VfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQkFDS0VORF9VUkw7XG5cbmV4cG9ydCBjb25zdCByZWdpc3RlclVzZXIgPSBhc3luYyAodXNlckRhdGE6IHtcbiAgbmFtZTogc3RyaW5nO1xuICBlbWFpbDogc3RyaW5nO1xuICBwYXNzd29yZDogc3RyaW5nO1xuICBwaG9uZT86IHN0cmluZztcbiAgY291cnNlPzogc3RyaW5nO1xuICByb2xlPzogJ2FkbWluJyB8ICdzdHVkZW50JzsgXG59KSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgdXJsID0gYCR7QkFTRV9VUkx9L2FwaS9hdXRoL3JlZ2lzdGVyYDtcbiAgICBjb25zb2xlLmxvZyhcIvCfkYkgRnVsbCBSZWdpc3RyYXRpb24gVVJMOlwiLCB1cmwpOyAvLyDwn5GIIHByaW50IHRoaXMhXG5cbiAgICBjb25zdCByZXMgPSBhd2FpdCBheGlvcy5wb3N0KHVybCwge1xuICAgICAgZnVsbE5hbWU6IHVzZXJEYXRhLm5hbWUsXG4gICAgICBlbWFpbDogdXNlckRhdGEuZW1haWwsXG4gICAgICBwYXNzd29yZDogdXNlckRhdGEucGFzc3dvcmQsXG4gICAgICBwaG9uZTogdXNlckRhdGEucGhvbmUsXG4gICAgICBjb3Vyc2U6IHVzZXJEYXRhLmNvdXJzZSxcbiAgICAgIHJvbGU6IHVzZXJEYXRhLnJvbGUgfHwgJ3N0dWRlbnQnLCAvLyBkZWZhdWx0IHRvICdzdHVkZW50JyBpZiBub3QgcHJvdmlkZWRcbiAgICB9LCB7ICBcbiAgICAgIHdpdGhDcmVkZW50aWFsczogdHJ1ZSxcbiAgICB9KTtcblxuICAgIHJldHVybiByZXMuZGF0YS51c2VyO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcihcIlJlZ2lzdHJhdGlvbiBlcnJvcjpcIiwgZXJyb3IpOyAvLyDwn5GIIGxvZyBlbnRpcmUgZXJyb3JcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBlcnJvcj8ucmVzcG9uc2U/LmRhdGE/Lm1lc3NhZ2UgfHwgJ1JlZ2lzdHJhdGlvbiBmYWlsZWQuIFBsZWFzZSB0cnkgYWdhaW4uJ1xuICAgICk7XG4gIH1cbn07XG5cbi8vID09PSBUSEUgVVNFUlxuXG5leHBvcnQgY29uc3QgZ2V0VXNlclByb2ZpbGUgPSBhc3luYyAodG9rZW46IHN0cmluZyk6IFByb21pc2U8VXNlclByb2ZpbGU+ID0+IHtcbiAgYXdhaXQgZGVsYXkoMzAwKTtcbiAgY29uc3QgdXNlcklkID0gdG9rZW4ucmVwbGFjZSgnbW9jay1qd3QtZm9yLScsICcnKTtcbiAgY29uc3QgdXNlciA9IG1vY2tVc2Vyc0RiLmZpbmQodSA9PiB1LmlkID09PSB1c2VySWQpO1xuICBpZiAoIXVzZXIpIHRocm93IG5ldyBFcnJvcihcIlVzZXIgbm90IGZvdW5kXCIpO1xuICByZXR1cm4gdXNlcjtcbn07XG5leHBvcnQgY29uc3QgdXBkYXRlVXNlclByb2ZpbGUgPSBhc3luYyAoXG4gIHVzZXJJZDogc3RyaW5nLFxuICBwcm9maWxlRGF0YTogUGFydGlhbDxVc2VyUHJvZmlsZT4sXG4gIHRva2VuOiBzdHJpbmdcbik6IFByb21pc2U8VXNlclByb2ZpbGU+ID0+IHtcbiAgYXdhaXQgZGVsYXkoNTAwKTtcbiAgaWYgKCF0b2tlbi5pbmNsdWRlcygnbW9jay1qd3QtZm9yLScpKSB0aHJvdyBuZXcgRXJyb3IoXCJVbmF1dGhvcml6ZWQgYWNjZXNzXCIpO1xuXG4gIGNvbnN0IHVzZXJJbmRleCA9IG1vY2tVc2Vyc0RiLmZpbmRJbmRleCh1ID0+IHUuaWQgPT09IHVzZXJJZCk7XG4gIGlmICh1c2VySW5kZXggPT09IC0xKSB0aHJvdyBuZXcgRXJyb3IoXCJVc2VyIG5vdCBmb3VuZCBmb3IgdXBkYXRlXCIpO1xuXG4gIE9iamVjdC5hc3NpZ24obW9ja1VzZXJzRGJbdXNlckluZGV4XSwgcHJvZmlsZURhdGEpO1xuICByZXR1cm4gbW9ja1VzZXJzRGJbdXNlckluZGV4XTtcbn07XG5cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyA9PT0gU1RVREVOVCBNQU5BR0VNRU5UIChBRE1JTilcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5pbnRlcmZhY2UgR2V0QWxsU3R1ZGVudHNPcHRpb25zIHtcbiAgcGFnZT86IG51bWJlcjtcbiAgbGltaXQ/OiBudW1iZXI7XG4gIHN0YXR1c0ZpbHRlcj86ICdBbGwnIHwgJ0FjdGl2ZScgfCAnR3JhZHVhdGVkJyB8ICdEcm9wcGVkJztcbn1cblxuZXhwb3J0IGNvbnN0IGdldEFsbFN0dWRlbnRzID0gYXN5bmMgKFxuICB0b2tlbjogc3RyaW5nLFxuICBvcHRpb25zOiBHZXRBbGxTdHVkZW50c09wdGlvbnMgPSB7fVxuKTogUHJvbWlzZTx7IHN0dWRlbnRzOiBTdHVkZW50UmVjb3JkW107IHRvdGFsOiBudW1iZXIgfT4gPT4ge1xuICBhd2FpdCBkZWxheSg4MDApO1xuICBpZiAoIXRva2VuLmluY2x1ZGVzKCdhZG1pbicpKSB0aHJvdyBuZXcgRXJyb3IoXCJVbmF1dGhvcml6ZWQgYWNjZXNzXCIpO1xuXG4gIGNvbnN0IHsgcGFnZSA9IDEsIGxpbWl0ID0gNSwgc3RhdHVzRmlsdGVyID0gJ0FsbCcgfSA9IG9wdGlvbnM7XG4gIGxldCBhbGxTdHVkZW50cyA9IGdldFN0dWRlbnRSZWNvcmRzKCk7XG5cbiAgaWYgKHN0YXR1c0ZpbHRlciAhPT0gJ0FsbCcpIHtcbiAgICBhbGxTdHVkZW50cyA9IGFsbFN0dWRlbnRzLmZpbHRlcihzID0+IHMuc3RhdHVzID09PSBzdGF0dXNGaWx0ZXIpO1xuICB9XG5cbiAgY29uc3QgdG90YWwgPSBhbGxTdHVkZW50cy5sZW5ndGg7XG4gIGNvbnN0IHBhZ2luYXRlZFN0dWRlbnRzID0gYWxsU3R1ZGVudHMuc2xpY2UoKHBhZ2UgLSAxKSAqIGxpbWl0LCBwYWdlICogbGltaXQpO1xuICByZXR1cm4geyBzdHVkZW50czogcGFnaW5hdGVkU3R1ZGVudHMsIHRvdGFsIH07XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlU3R1ZGVudCA9IGFzeW5jIChcbiAgc3R1ZGVudERhdGE6IE9taXQ8U3R1ZGVudFJlY29yZCwgJ2lkJz4sXG4gIHRva2VuOiBzdHJpbmdcbik6IFByb21pc2U8VXNlclByb2ZpbGU+ID0+IHtcbiAgYXdhaXQgZGVsYXkoNTAwKTtcbiAgaWYgKCF0b2tlbi5pbmNsdWRlcygnYWRtaW4nKSkgdGhyb3cgbmV3IEVycm9yKFwiVW5hdXRob3JpemVkIGFjY2Vzc1wiKTtcbiAgaWYgKG1vY2tVc2Vyc0RiLnNvbWUodXNlciA9PiB1c2VyLmVtYWlsID09PSBzdHVkZW50RGF0YS5lbWFpbCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Egc3R1ZGVudCB3aXRoIHRoaXMgZW1haWwgYWxyZWFkeSBleGlzdHMuJyk7XG4gIH1cblxuICBjb25zdCBuZXdVc2VyOiBVc2VyUHJvZmlsZSA9IHtcbiAgICBpZDogYHVzZXItJHtEYXRlLm5vdygpfWAsXG4gICAgbmFtZTogc3R1ZGVudERhdGEubmFtZSxcbiAgICBlbWFpbDogc3R1ZGVudERhdGEuZW1haWwsXG4gICAgcm9sZTogJ3N0dWRlbnQnLFxuICAgIGNvdXJzZTogc3R1ZGVudERhdGEuY291cnNlLFxuICAgIGVucm9sbG1lbnRZZWFyOiBzdHVkZW50RGF0YS5lbnJvbGxtZW50WWVhcixcbiAgfTtcbiAgbW9ja1VzZXJzRGIucHVzaChuZXdVc2VyKTtcbiAgcmV0dXJuIG5ld1VzZXI7XG59O1xuXG5leHBvcnQgY29uc3QgdXBkYXRlU3R1ZGVudCA9IGFzeW5jIChcbiAgaWQ6IHN0cmluZyxcbiAgc3R1ZGVudERhdGE6IFBhcnRpYWw8U3R1ZGVudFJlY29yZD4sXG4gIHRva2VuOiBzdHJpbmdcbik6IFByb21pc2U8VXNlclByb2ZpbGU+ID0+IHtcbiAgYXdhaXQgZGVsYXkoNTAwKTtcbiAgaWYgKCF0b2tlbi5pbmNsdWRlcygnYWRtaW4nKSkgdGhyb3cgbmV3IEVycm9yKFwiVW5hdXRob3JpemVkIGFjY2Vzc1wiKTtcblxuICBjb25zdCB1c2VySW5kZXggPSBtb2NrVXNlcnNEYi5maW5kSW5kZXgodSA9PiB1LmlkID09PSBpZCk7XG4gIGlmICh1c2VySW5kZXggPT09IC0xKSB0aHJvdyBuZXcgRXJyb3IoXCJVc2VyIG5vdCBmb3VuZCBmb3IgdXBkYXRlXCIpO1xuXG4gIE9iamVjdC5hc3NpZ24obW9ja1VzZXJzRGJbdXNlckluZGV4XSwgc3R1ZGVudERhdGEpO1xuICByZXR1cm4gbW9ja1VzZXJzRGJbdXNlckluZGV4XTtcbn07XG5cbmV4cG9ydCBjb25zdCBkZWxldGVTdHVkZW50ID0gYXN5bmMgKGlkOiBzdHJpbmcsIHRva2VuOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgYXdhaXQgZGVsYXkoNTAwKTtcbiAgaWYgKCF0b2tlbi5pbmNsdWRlcygnYWRtaW4nKSkgdGhyb3cgbmV3IEVycm9yKFwiVW5hdXRob3JpemVkIGFjY2Vzc1wiKTtcbiAgbW9ja1VzZXJzRGIgPSBtb2NrVXNlcnNEYi5maWx0ZXIodSA9PiB1LmlkICE9PSBpZCk7XG59O1xuXG5leHBvcnQgY29uc3QgY2hhbmdlVXNlclJvbGUgPSBhc3luYyAoXG4gIHVzZXJJZDogc3RyaW5nLFxuICBuZXdSb2xlOiAnYWRtaW4nIHwgJ3N0dWRlbnQnLFxuICB0b2tlbjogc3RyaW5nXG4pOiBQcm9taXNlPFVzZXJQcm9maWxlPiA9PiB7XG4gIGF3YWl0IGRlbGF5KDUwMCk7XG4gIGlmICghdG9rZW4uaW5jbHVkZXMoJ2FkbWluJykpIHRocm93IG5ldyBFcnJvcihcIlVuYXV0aG9yaXplZCBhY2Nlc3NcIik7XG5cbiAgY29uc3QgdXNlckluZGV4ID0gbW9ja1VzZXJzRGIuZmluZEluZGV4KHUgPT4gdS5pZCA9PT0gdXNlcklkKTtcbiAgaWYgKHVzZXJJbmRleCA9PT0gLTEpIHRocm93IG5ldyBFcnJvcihcIlVzZXIgbm90IGZvdW5kIGZvciByb2xlIGNoYW5nZVwiKTtcblxuICBtb2NrVXNlcnNEYlt1c2VySW5kZXhdLnJvbGUgPSBuZXdSb2xlO1xuICByZXR1cm4gbW9ja1VzZXJzRGJbdXNlckluZGV4XTtcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gPT09IFVTRVIgUFJPRklMRSAmIERBU0hCT0FSRFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCBjb25zdCBnZXRBZG1pbkRhc2hib2FyZFN0YXRzID0gYXN5bmMgKFxuICB0b2tlbjogc3RyaW5nXG4pOiBQcm9taXNlPHsgdG90YWw6IG51bWJlcjsgYWN0aXZlOiBudW1iZXI7IGdyYWR1YXRlZDogbnVtYmVyIH0+ID0+IHtcbiAgYXdhaXQgZGVsYXkoNDAwKTtcbiAgaWYgKCF0b2tlbi5pbmNsdWRlcygnYWRtaW4nKSkgdGhyb3cgbmV3IEVycm9yKFwiVW5hdXRob3JpemVkIGFjY2Vzc1wiKTtcblxuICBjb25zdCBhbGxTdHVkZW50cyA9IGdldFN0dWRlbnRSZWNvcmRzKCk7XG4gIHJldHVybiB7XG4gICAgdG90YWw6IGFsbFN0dWRlbnRzLmxlbmd0aCxcbiAgICBhY3RpdmU6IGFsbFN0dWRlbnRzLmZpbHRlcihzID0+IHMuc3RhdHVzID09PSAnQWN0aXZlJykubGVuZ3RoLFxuICAgIGdyYWR1YXRlZDogYWxsU3R1ZGVudHMuZmlsdGVyKHMgPT4gcy5zdGF0dXMgPT09ICdHcmFkdWF0ZWQnKS5sZW5ndGgsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0TXlQcm9maWxlID0gYXN5bmMgKGFjY2Vzc1Rva2VuOiBzdHJpbmcpOiBQcm9taXNlPFVzZXJQcm9maWxlPiA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MuZ2V0KGAke3Byb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0JBQ0tFTkRfVVJMfS9hcGkvYXV0aC9tZWAsIHtcbiAgICBoZWFkZXJzOiB7XG4gICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7YWNjZXNzVG9rZW59YCxcbiAgICB9LFxuICB9KTtcblxuICBjb25zdCB1c2VyID0gcmVzcG9uc2UuZGF0YTtcblxuICByZXR1cm4ge1xuICAgIGlkOiB1c2VyLmlkLFxuICAgIG5hbWU6IHVzZXIuZnVsbE5hbWUsIC8vIE1hcCBmdWxsTmFtZSB0byBuYW1lXG4gICAgZW1haWw6IHVzZXIuZW1haWwsXG4gICAgcGhvbmU6IHVzZXIucGhvbmUsXG4gICAgcm9sZTogdXNlci5yb2xlLFxuICAgIGNvdXJzZTogdXNlci5jb3Vyc2UsXG4gICAgZW5yb2xsbWVudFllYXI6IHVzZXIuZW5yb2xsbWVudFllYXIsXG4gICAgam9pbmVkQXQ6IHVzZXIuY3JlYXRlZEF0IHx8IHVzZXIuam9pbmVkQXQsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgdXBkYXRlTXlQcm9maWxlID0gYXN5bmMgKFxuICBwcm9maWxlRGF0YTogUGFydGlhbDxVc2VyUHJvZmlsZT4sXG4gIHRva2VuOiBzdHJpbmdcbik6IFByb21pc2U8VXNlclByb2ZpbGU+ID0+IHtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5wdXQoXG4gICAgYCR7cHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQkFDS0VORF9VUkx9L2FwaS91c2Vycy9tZWAsIC8vIE1ha2Ugc3VyZSB0aGlzIG1hdGNoZXMgeW91ciBiYWNrZW5kIHJvdXRlXG4gICAgcHJvZmlsZURhdGEsXG4gICAge1xuICAgICAgaGVhZGVyczoge1xuICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCxcbiAgICAgIH0sXG4gICAgfVxuICApO1xuXG4gIGNvbnN0IHVzZXIgPSByZXNwb25zZS5kYXRhO1xuXG4gIHJldHVybiB7XG4gICAgaWQ6IHVzZXIuaWQsXG4gICAgbmFtZTogdXNlci5mdWxsTmFtZSwgLy8gbm9ybWFsaXplIGJhY2tlbmQgZmllbGRcbiAgICBlbWFpbDogdXNlci5lbWFpbCxcbiAgICBwaG9uZTogdXNlci5waG9uZSxcbiAgICByb2xlOiB1c2VyLnJvbGUsXG4gICAgY291cnNlOiB1c2VyLmNvdXJzZSxcbiAgICBlbnJvbGxtZW50WWVhcjogdXNlci5lbnJvbGxtZW50WWVhcixcbiAgICBqb2luZWRBdDogdXNlci5jcmVhdGVkQXQgfHwgdXNlci5qb2luZWRBdCxcbiAgfTtcbn07XG5cbiJdLCJuYW1lcyI6WyJheGlvcyIsImRlbGF5IiwibXMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJtb2NrVXNlcnNEYiIsImlkIiwibmFtZSIsImVtYWlsIiwicm9sZSIsInBob25lIiwiY291cnNlIiwiZW5yb2xsbWVudFllYXIiLCJnZXRTdHVkZW50UmVjb3JkcyIsImZpbHRlciIsInVzZXIiLCJtYXAiLCJzdGF0dXMiLCJsb2dpblVzZXIiLCJwYXNzd29yZCIsInJlc3BvbnNlIiwicG9zdCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19CQUNLRU5EX1VSTCIsInRva2VuIiwiZGF0YSIsImZvcm1hdHRlZFVzZXIiLCJmdWxsTmFtZSIsInByb2ZpbGVQaWN0dXJlIiwiam9pbmVkQXQiLCJjcmVhdGVkQXQiLCJlcnJvciIsIm1lc3NhZ2UiLCJFcnJvciIsIkJBU0VfVVJMIiwicmVnaXN0ZXJVc2VyIiwidXNlckRhdGEiLCJ1cmwiLCJjb25zb2xlIiwibG9nIiwicmVzIiwid2l0aENyZWRlbnRpYWxzIiwiZ2V0VXNlclByb2ZpbGUiLCJ1c2VySWQiLCJyZXBsYWNlIiwiZmluZCIsInUiLCJ1cGRhdGVVc2VyUHJvZmlsZSIsInByb2ZpbGVEYXRhIiwiaW5jbHVkZXMiLCJ1c2VySW5kZXgiLCJmaW5kSW5kZXgiLCJPYmplY3QiLCJhc3NpZ24iLCJnZXRBbGxTdHVkZW50cyIsIm9wdGlvbnMiLCJwYWdlIiwibGltaXQiLCJzdGF0dXNGaWx0ZXIiLCJhbGxTdHVkZW50cyIsInMiLCJ0b3RhbCIsImxlbmd0aCIsInBhZ2luYXRlZFN0dWRlbnRzIiwic2xpY2UiLCJzdHVkZW50cyIsImNyZWF0ZVN0dWRlbnQiLCJzdHVkZW50RGF0YSIsInNvbWUiLCJuZXdVc2VyIiwiRGF0ZSIsIm5vdyIsInB1c2giLCJ1cGRhdGVTdHVkZW50IiwiZGVsZXRlU3R1ZGVudCIsImNoYW5nZVVzZXJSb2xlIiwibmV3Um9sZSIsImdldEFkbWluRGFzaGJvYXJkU3RhdHMiLCJhY3RpdmUiLCJncmFkdWF0ZWQiLCJnZXRNeVByb2ZpbGUiLCJhY2Nlc3NUb2tlbiIsImdldCIsImhlYWRlcnMiLCJBdXRob3JpemF0aW9uIiwidXBkYXRlTXlQcm9maWxlIiwicHV0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/api.ts\n"));

/***/ })

});