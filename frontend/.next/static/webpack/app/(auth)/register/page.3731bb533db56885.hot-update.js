"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(auth)/register/page",{

/***/ "(app-pages-browser)/./src/lib/api.ts":
/*!************************!*\
  !*** ./src/lib/api.ts ***!
  \************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   changeUserRole: () => (/* binding */ changeUserRole),\n/* harmony export */   createStudent: () => (/* binding */ createStudent),\n/* harmony export */   deleteStudent: () => (/* binding */ deleteStudent),\n/* harmony export */   getAdminDashboardStats: () => (/* binding */ getAdminDashboardStats),\n/* harmony export */   getAllStudents: () => (/* binding */ getAllStudents),\n/* harmony export */   getMyProfile: () => (/* binding */ getMyProfile),\n/* harmony export */   getUserProfile: () => (/* binding */ getUserProfile),\n/* harmony export */   loginUser: () => (/* binding */ loginUser),\n/* harmony export */   registerUser: () => (/* binding */ registerUser),\n/* harmony export */   updateMyProfile: () => (/* binding */ updateMyProfile),\n/* harmony export */   updateStudent: () => (/* binding */ updateStudent),\n/* harmony export */   updateUserProfile: () => (/* binding */ updateUserProfile)\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/../node_modules/axios/lib/axios.js\");\n\n// Simulate network delay for realism\nconst delay = (ms)=>new Promise((resolve)=>setTimeout(resolve, ms));\n// =====================================\n// === MOCKED DATABASE (SOURCE OF TRUTH)\n// =====================================\nlet mockUsersDb = [\n    {\n        id: 'admin-01',\n        name: 'Admin User',\n        email: 'admin@test.com',\n        role: 'admin',\n        phone: '123-456-7890'\n    },\n    {\n        id: 'student-01',\n        name: 'Student User',\n        email: 'student@test.com',\n        role: 'student',\n        phone: '098-765-4321',\n        course: 'Computer Science',\n        enrollmentYear: 2022\n    },\n    {\n        id: 's1',\n        name: 'Alice Johnson',\n        email: 'alice@test.com',\n        role: 'student',\n        phone: '111-222-3333',\n        course: 'Web Development',\n        enrollmentYear: 2023\n    },\n    {\n        id: 's2',\n        name: 'Bob Williams',\n        email: 'bob@test.com',\n        role: 'student',\n        phone: '444-555-6666',\n        course: 'Data Science',\n        enrollmentYear: 2022\n    },\n    {\n        id: 's3',\n        name: 'Charlie Brown',\n        email: 'charlie@test.com',\n        role: 'student',\n        phone: '777-888-9999',\n        course: 'UX/UI Design',\n        enrollmentYear: 2023\n    },\n    {\n        id: 's4',\n        name: 'Diana Prince',\n        email: 'diana@test.com',\n        role: 'student',\n        phone: '121-232-3434',\n        course: 'Data Science',\n        enrollmentYear: 2024\n    }\n];\n// ============================================\n// === UTILITY FUNCTION: StudentRecord Mapping\n// ============================================\nconst getStudentRecords = ()=>{\n    return mockUsersDb.filter((user)=>user.role === 'student').map((user)=>({\n            id: user.id,\n            name: user.name,\n            email: user.email,\n            course: user.course || 'N/A',\n            enrollmentYear: user.enrollmentYear || 0,\n            status: user.enrollmentYear && user.enrollmentYear < 2023 ? 'Graduated' : 'Active'\n        }));\n};\n// ==============================\n// === AUTHENTICATION\n// ==============================\n// === LOGIN USER\nconst loginUser = async (email, password)=>{\n    try {\n        const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].post(\"\".concat(\"http://localhost:5001\", \"/api/auth/login\"), {\n            email,\n            password\n        });\n        return response.data;\n    } catch (error) {\n        var _error_response_data, _error_response;\n        const message = (error === null || error === void 0 ? void 0 : (_error_response = error.response) === null || _error_response === void 0 ? void 0 : (_error_response_data = _error_response.data) === null || _error_response_data === void 0 ? void 0 : _error_response_data.message) || 'Login failed';\n        throw new Error(message);\n    }\n};\n// === REGISTER USER\nconst BASE_URL = \"http://localhost:5001\";\nconst registerUser = async (userData)=>{\n    try {\n        const url = \"\".concat(BASE_URL, \"/api/auth/register\");\n        console.log(\"ðŸ‘‰ Full Registration URL:\", url); // ðŸ‘ˆ print this!\n        const res = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].post(url, {\n            fullName: userData.name,\n            email: userData.email,\n            password: userData.password,\n            phone: userData.phone,\n            course: userData.course\n        }, {\n            withCredentials: true\n        });\n        return res.data.user;\n    } catch (error) {\n        var _error_response_data, _error_response;\n        console.error(\"Registration error:\", error); // ðŸ‘ˆ log entire error\n        throw new Error((error === null || error === void 0 ? void 0 : (_error_response = error.response) === null || _error_response === void 0 ? void 0 : (_error_response_data = _error_response.data) === null || _error_response_data === void 0 ? void 0 : _error_response_data.message) || 'Registration failed. Please try again.');\n    }\n};\n// === THE USER\nconst getUserProfile = async (token)=>{\n    await delay(300);\n    const userId = token.replace('mock-jwt-for-', '');\n    const user = mockUsersDb.find((u)=>u.id === userId);\n    if (!user) throw new Error(\"User not found\");\n    return user;\n};\nconst updateUserProfile = async (userId, profileData, token)=>{\n    await delay(500);\n    if (!token.includes('mock-jwt-for-')) throw new Error(\"Unauthorized access\");\n    const userIndex = mockUsersDb.findIndex((u)=>u.id === userId);\n    if (userIndex === -1) throw new Error(\"User not found for update\");\n    Object.assign(mockUsersDb[userIndex], profileData);\n    return mockUsersDb[userIndex];\n};\nconst getAllStudents = async function(token) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    await delay(800);\n    if (!token.includes('admin')) throw new Error(\"Unauthorized access\");\n    const { page = 1, limit = 5, statusFilter = 'All' } = options;\n    let allStudents = getStudentRecords();\n    if (statusFilter !== 'All') {\n        allStudents = allStudents.filter((s)=>s.status === statusFilter);\n    }\n    const total = allStudents.length;\n    const paginatedStudents = allStudents.slice((page - 1) * limit, page * limit);\n    return {\n        students: paginatedStudents,\n        total\n    };\n};\nconst createStudent = async (studentData, token)=>{\n    await delay(500);\n    if (!token.includes('admin')) throw new Error(\"Unauthorized access\");\n    if (mockUsersDb.some((user)=>user.email === studentData.email)) {\n        throw new Error('A student with this email already exists.');\n    }\n    const newUser = {\n        id: \"user-\".concat(Date.now()),\n        name: studentData.name,\n        email: studentData.email,\n        role: 'student',\n        course: studentData.course,\n        enrollmentYear: studentData.enrollmentYear\n    };\n    mockUsersDb.push(newUser);\n    return newUser;\n};\nconst updateStudent = async (id, studentData, token)=>{\n    await delay(500);\n    if (!token.includes('admin')) throw new Error(\"Unauthorized access\");\n    const userIndex = mockUsersDb.findIndex((u)=>u.id === id);\n    if (userIndex === -1) throw new Error(\"User not found for update\");\n    Object.assign(mockUsersDb[userIndex], studentData);\n    return mockUsersDb[userIndex];\n};\nconst deleteStudent = async (id, token)=>{\n    await delay(500);\n    if (!token.includes('admin')) throw new Error(\"Unauthorized access\");\n    mockUsersDb = mockUsersDb.filter((u)=>u.id !== id);\n};\nconst changeUserRole = async (userId, newRole, token)=>{\n    await delay(500);\n    if (!token.includes('admin')) throw new Error(\"Unauthorized access\");\n    const userIndex = mockUsersDb.findIndex((u)=>u.id === userId);\n    if (userIndex === -1) throw new Error(\"User not found for role change\");\n    mockUsersDb[userIndex].role = newRole;\n    return mockUsersDb[userIndex];\n};\n// ==============================\n// === USER PROFILE & DASHBOARD\n// ==============================\nconst getAdminDashboardStats = async (token)=>{\n    await delay(400);\n    if (!token.includes('admin')) throw new Error(\"Unauthorized access\");\n    const allStudents = getStudentRecords();\n    return {\n        total: allStudents.length,\n        active: allStudents.filter((s)=>s.status === 'Active').length,\n        graduated: allStudents.filter((s)=>s.status === 'Graduated').length\n    };\n};\nconst getMyProfile = async (token)=>{\n    await delay(300);\n    const userId = token.replace('mock-jwt-for-', '');\n    const user = mockUsersDb.find((u)=>u.id === userId);\n    if (!user) throw new Error(\"Invalid session token.\");\n    return {\n        ...user\n    };\n};\nconst updateMyProfile = async (profileData, token)=>{\n    await delay(500);\n    const userId = token.replace('mock-jwt-for-', '');\n    const userIndex = mockUsersDb.findIndex((u)=>u.id === userId);\n    if (userIndex === -1) throw new Error(\"User not found to update profile.\");\n    Object.assign(mockUsersDb[userIndex], profileData);\n    return {\n        ...mockUsersDb[userIndex]\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SUFDcEIsT0FBTztRQUNMNkMsT0FBT0YsWUFBWUcsTUFBTTtRQUN6QmdCLFFBQVFuQixZQUFZMUMsTUFBTSxDQUFDMkMsQ0FBQUEsSUFBS0EsRUFBRXhDLE1BQU0sS0FBSyxVQUFVMEMsTUFBTTtRQUM3RGlCLFdBQVdwQixZQUFZMUMsTUFBTSxDQUFDMkMsQ0FBQUEsSUFBS0EsRUFBRXhDLE1BQU0sS0FBSyxhQUFhMEMsTUFBTTtJQUNyRTtBQUNGLEVBQUU7QUFFSyxNQUFNa0IsZUFBZSxPQUFPdEM7SUFDakMsTUFBTXZDLE1BQU07SUFDWixNQUFNd0MsU0FBU0QsTUFBTUUsT0FBTyxDQUFDLGlCQUFpQjtJQUM5QyxNQUFNMUIsT0FBT1YsWUFBWXFDLElBQUksQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRXJDLEVBQUUsS0FBS2tDO0lBQzVDLElBQUksQ0FBQ3pCLE1BQU0sTUFBTSxJQUFJYSxNQUFNO0lBQzNCLE9BQU87UUFBRSxHQUFHYixJQUFJO0lBQUM7QUFDbkIsRUFBRTtBQUVLLE1BQU0rRCxrQkFBa0IsT0FDN0JqQyxhQUNBTjtJQUVBLE1BQU12QyxNQUFNO0lBQ1osTUFBTXdDLFNBQVNELE1BQU1FLE9BQU8sQ0FBQyxpQkFBaUI7SUFDOUMsTUFBTU0sWUFBWTFDLFlBQVkyQyxTQUFTLENBQUNMLENBQUFBLElBQUtBLEVBQUVyQyxFQUFFLEtBQUtrQztJQUN0RCxJQUFJTyxjQUFjLENBQUMsR0FBRyxNQUFNLElBQUluQixNQUFNO0lBQ3RDcUIsT0FBT0MsTUFBTSxDQUFDN0MsV0FBVyxDQUFDMEMsVUFBVSxFQUFFRjtJQUN0QyxPQUFPO1FBQUUsR0FBR3hDLFdBQVcsQ0FBQzBDLFVBQVU7SUFBQztBQUNyQyxFQUFFIiwic291cmNlcyI6WyIvVXNlcnMveW91bmdzYXZhZ2Uvc3R1ZGVudC1tYW5hZ2VtZW50LXN5c3RlbS0vZnJvbnRlbmQvc3JjL2xpYi9hcGkudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXV0aFJlc3BvbnNlLCBTdHVkZW50UmVjb3JkLCBVc2VyUHJvZmlsZSB9IGZyb20gXCJAL3R5cGVzXCI7XG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xuXG4vLyBTaW11bGF0ZSBuZXR3b3JrIGRlbGF5IGZvciByZWFsaXNtXG5jb25zdCBkZWxheSA9IChtczogbnVtYmVyKSA9PiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gPT09IE1PQ0tFRCBEQVRBQkFTRSAoU09VUkNFIE9GIFRSVVRIKVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5sZXQgbW9ja1VzZXJzRGI6IFVzZXJQcm9maWxlW10gPSBbXG4gIHsgaWQ6ICdhZG1pbi0wMScsIG5hbWU6ICdBZG1pbiBVc2VyJywgZW1haWw6ICdhZG1pbkB0ZXN0LmNvbScsIHJvbGU6ICdhZG1pbicsIHBob25lOiAnMTIzLTQ1Ni03ODkwJyB9LFxuICB7IGlkOiAnc3R1ZGVudC0wMScsIG5hbWU6ICdTdHVkZW50IFVzZXInLCBlbWFpbDogJ3N0dWRlbnRAdGVzdC5jb20nLCByb2xlOiAnc3R1ZGVudCcsIHBob25lOiAnMDk4LTc2NS00MzIxJywgY291cnNlOiAnQ29tcHV0ZXIgU2NpZW5jZScsIGVucm9sbG1lbnRZZWFyOiAyMDIyIH0sXG4gIHsgaWQ6ICdzMScsIG5hbWU6ICdBbGljZSBKb2huc29uJywgZW1haWw6ICdhbGljZUB0ZXN0LmNvbScsIHJvbGU6ICdzdHVkZW50JywgcGhvbmU6ICcxMTEtMjIyLTMzMzMnLCBjb3Vyc2U6ICdXZWIgRGV2ZWxvcG1lbnQnLCBlbnJvbGxtZW50WWVhcjogMjAyMyB9LFxuICB7IGlkOiAnczInLCBuYW1lOiAnQm9iIFdpbGxpYW1zJywgZW1haWw6ICdib2JAdGVzdC5jb20nLCByb2xlOiAnc3R1ZGVudCcsIHBob25lOiAnNDQ0LTU1NS02NjY2JywgY291cnNlOiAnRGF0YSBTY2llbmNlJywgZW5yb2xsbWVudFllYXI6IDIwMjIgfSxcbiAgeyBpZDogJ3MzJywgbmFtZTogJ0NoYXJsaWUgQnJvd24nLCBlbWFpbDogJ2NoYXJsaWVAdGVzdC5jb20nLCByb2xlOiAnc3R1ZGVudCcsIHBob25lOiAnNzc3LTg4OC05OTk5JywgY291cnNlOiAnVVgvVUkgRGVzaWduJywgZW5yb2xsbWVudFllYXI6IDIwMjMgfSxcbiAgeyBpZDogJ3M0JywgbmFtZTogJ0RpYW5hIFByaW5jZScsIGVtYWlsOiAnZGlhbmFAdGVzdC5jb20nLCByb2xlOiAnc3R1ZGVudCcsIHBob25lOiAnMTIxLTIzMi0zNDM0JywgY291cnNlOiAnRGF0YSBTY2llbmNlJywgZW5yb2xsbWVudFllYXI6IDIwMjQgfSxcbl07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyA9PT0gVVRJTElUWSBGVU5DVElPTjogU3R1ZGVudFJlY29yZCBNYXBwaW5nXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5jb25zdCBnZXRTdHVkZW50UmVjb3JkcyA9ICgpOiBTdHVkZW50UmVjb3JkW10gPT4ge1xuICByZXR1cm4gbW9ja1VzZXJzRGJcbiAgICAuZmlsdGVyKHVzZXIgPT4gdXNlci5yb2xlID09PSAnc3R1ZGVudCcpXG4gICAgLm1hcCh1c2VyID0+ICh7XG4gICAgICBpZDogdXNlci5pZCxcbiAgICAgIG5hbWU6IHVzZXIubmFtZSxcbiAgICAgIGVtYWlsOiB1c2VyLmVtYWlsLFxuICAgICAgY291cnNlOiB1c2VyLmNvdXJzZSB8fCAnTi9BJyxcbiAgICAgIGVucm9sbG1lbnRZZWFyOiB1c2VyLmVucm9sbG1lbnRZZWFyIHx8IDAsXG4gICAgICBzdGF0dXM6ICh1c2VyLmVucm9sbG1lbnRZZWFyICYmIHVzZXIuZW5yb2xsbWVudFllYXIgPCAyMDIzKSA/ICdHcmFkdWF0ZWQnIDogJ0FjdGl2ZScsXG4gICAgfSkpO1xufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyA9PT0gQVVUSEVOVElDQVRJT05cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vLyA9PT0gTE9HSU4gVVNFUlxuZXhwb3J0IGNvbnN0IGxvZ2luVXNlciA9IGFzeW5jIChlbWFpbDogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKTogUHJvbWlzZTxBdXRoUmVzcG9uc2U+ID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLnBvc3QoYCR7cHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQkFDS0VORF9VUkx9L2FwaS9hdXRoL2xvZ2luYCwge1xuICAgICAgZW1haWwsXG4gICAgICBwYXNzd29yZCxcbiAgICB9KTtcblxuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGVycm9yPy5yZXNwb25zZT8uZGF0YT8ubWVzc2FnZSB8fCAnTG9naW4gZmFpbGVkJztcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn07XG5cbi8vID09PSBSRUdJU1RFUiBVU0VSXG5jb25zdCBCQVNFX1VSTCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0JBQ0tFTkRfVVJMO1xuXG5leHBvcnQgY29uc3QgcmVnaXN0ZXJVc2VyID0gYXN5bmMgKHVzZXJEYXRhOiB7XG4gIG5hbWU6IHN0cmluZztcbiAgZW1haWw6IHN0cmluZztcbiAgcGFzc3dvcmQ6IHN0cmluZztcbiAgcGhvbmU/OiBzdHJpbmc7XG4gIGNvdXJzZT86IHN0cmluZztcbn0pID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB1cmwgPSBgJHtCQVNFX1VSTH0vYXBpL2F1dGgvcmVnaXN0ZXJgO1xuICAgIGNvbnNvbGUubG9nKFwi8J+RiSBGdWxsIFJlZ2lzdHJhdGlvbiBVUkw6XCIsIHVybCk7IC8vIPCfkYggcHJpbnQgdGhpcyFcblxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGF4aW9zLnBvc3QodXJsLCB7XG4gICAgICBmdWxsTmFtZTogdXNlckRhdGEubmFtZSxcbiAgICAgIGVtYWlsOiB1c2VyRGF0YS5lbWFpbCxcbiAgICAgIHBhc3N3b3JkOiB1c2VyRGF0YS5wYXNzd29yZCxcbiAgICAgIHBob25lOiB1c2VyRGF0YS5waG9uZSxcbiAgICAgIGNvdXJzZTogdXNlckRhdGEuY291cnNlLFxuICAgIH0sIHsgIFxuICAgICAgd2l0aENyZWRlbnRpYWxzOiB0cnVlLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlcy5kYXRhLnVzZXI7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiUmVnaXN0cmF0aW9uIGVycm9yOlwiLCBlcnJvcik7IC8vIPCfkYggbG9nIGVudGlyZSBlcnJvclxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGVycm9yPy5yZXNwb25zZT8uZGF0YT8ubWVzc2FnZSB8fCAnUmVnaXN0cmF0aW9uIGZhaWxlZC4gUGxlYXNlIHRyeSBhZ2Fpbi4nXG4gICAgKTtcbiAgfVxufTtcblxuLy8gPT09IFRIRSBVU0VSXG5cbmV4cG9ydCBjb25zdCBnZXRVc2VyUHJvZmlsZSA9IGFzeW5jICh0b2tlbjogc3RyaW5nKTogUHJvbWlzZTxVc2VyUHJvZmlsZT4gPT4ge1xuICBhd2FpdCBkZWxheSgzMDApO1xuICBjb25zdCB1c2VySWQgPSB0b2tlbi5yZXBsYWNlKCdtb2NrLWp3dC1mb3ItJywgJycpO1xuICBjb25zdCB1c2VyID0gbW9ja1VzZXJzRGIuZmluZCh1ID0+IHUuaWQgPT09IHVzZXJJZCk7XG4gIGlmICghdXNlcikgdGhyb3cgbmV3IEVycm9yKFwiVXNlciBub3QgZm91bmRcIik7XG4gIHJldHVybiB1c2VyO1xufTtcbmV4cG9ydCBjb25zdCB1cGRhdGVVc2VyUHJvZmlsZSA9IGFzeW5jIChcbiAgdXNlcklkOiBzdHJpbmcsXG4gIHByb2ZpbGVEYXRhOiBQYXJ0aWFsPFVzZXJQcm9maWxlPixcbiAgdG9rZW46IHN0cmluZ1xuKTogUHJvbWlzZTxVc2VyUHJvZmlsZT4gPT4ge1xuICBhd2FpdCBkZWxheSg1MDApO1xuICBpZiAoIXRva2VuLmluY2x1ZGVzKCdtb2NrLWp3dC1mb3ItJykpIHRocm93IG5ldyBFcnJvcihcIlVuYXV0aG9yaXplZCBhY2Nlc3NcIik7XG5cbiAgY29uc3QgdXNlckluZGV4ID0gbW9ja1VzZXJzRGIuZmluZEluZGV4KHUgPT4gdS5pZCA9PT0gdXNlcklkKTtcbiAgaWYgKHVzZXJJbmRleCA9PT0gLTEpIHRocm93IG5ldyBFcnJvcihcIlVzZXIgbm90IGZvdW5kIGZvciB1cGRhdGVcIik7XG5cbiAgT2JqZWN0LmFzc2lnbihtb2NrVXNlcnNEYlt1c2VySW5kZXhdLCBwcm9maWxlRGF0YSk7XG4gIHJldHVybiBtb2NrVXNlcnNEYlt1c2VySW5kZXhdO1xufTtcblxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vID09PSBTVFVERU5UIE1BTkFHRU1FTlQgKEFETUlOKVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmludGVyZmFjZSBHZXRBbGxTdHVkZW50c09wdGlvbnMge1xuICBwYWdlPzogbnVtYmVyO1xuICBsaW1pdD86IG51bWJlcjtcbiAgc3RhdHVzRmlsdGVyPzogJ0FsbCcgfCAnQWN0aXZlJyB8ICdHcmFkdWF0ZWQnIHwgJ0Ryb3BwZWQnO1xufVxuXG5leHBvcnQgY29uc3QgZ2V0QWxsU3R1ZGVudHMgPSBhc3luYyAoXG4gIHRva2VuOiBzdHJpbmcsXG4gIG9wdGlvbnM6IEdldEFsbFN0dWRlbnRzT3B0aW9ucyA9IHt9XG4pOiBQcm9taXNlPHsgc3R1ZGVudHM6IFN0dWRlbnRSZWNvcmRbXTsgdG90YWw6IG51bWJlciB9PiA9PiB7XG4gIGF3YWl0IGRlbGF5KDgwMCk7XG4gIGlmICghdG9rZW4uaW5jbHVkZXMoJ2FkbWluJykpIHRocm93IG5ldyBFcnJvcihcIlVuYXV0aG9yaXplZCBhY2Nlc3NcIik7XG5cbiAgY29uc3QgeyBwYWdlID0gMSwgbGltaXQgPSA1LCBzdGF0dXNGaWx0ZXIgPSAnQWxsJyB9ID0gb3B0aW9ucztcbiAgbGV0IGFsbFN0dWRlbnRzID0gZ2V0U3R1ZGVudFJlY29yZHMoKTtcblxuICBpZiAoc3RhdHVzRmlsdGVyICE9PSAnQWxsJykge1xuICAgIGFsbFN0dWRlbnRzID0gYWxsU3R1ZGVudHMuZmlsdGVyKHMgPT4gcy5zdGF0dXMgPT09IHN0YXR1c0ZpbHRlcik7XG4gIH1cblxuICBjb25zdCB0b3RhbCA9IGFsbFN0dWRlbnRzLmxlbmd0aDtcbiAgY29uc3QgcGFnaW5hdGVkU3R1ZGVudHMgPSBhbGxTdHVkZW50cy5zbGljZSgocGFnZSAtIDEpICogbGltaXQsIHBhZ2UgKiBsaW1pdCk7XG4gIHJldHVybiB7IHN0dWRlbnRzOiBwYWdpbmF0ZWRTdHVkZW50cywgdG90YWwgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVTdHVkZW50ID0gYXN5bmMgKFxuICBzdHVkZW50RGF0YTogT21pdDxTdHVkZW50UmVjb3JkLCAnaWQnPixcbiAgdG9rZW46IHN0cmluZ1xuKTogUHJvbWlzZTxVc2VyUHJvZmlsZT4gPT4ge1xuICBhd2FpdCBkZWxheSg1MDApO1xuICBpZiAoIXRva2VuLmluY2x1ZGVzKCdhZG1pbicpKSB0aHJvdyBuZXcgRXJyb3IoXCJVbmF1dGhvcml6ZWQgYWNjZXNzXCIpO1xuICBpZiAobW9ja1VzZXJzRGIuc29tZSh1c2VyID0+IHVzZXIuZW1haWwgPT09IHN0dWRlbnREYXRhLmVtYWlsKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQSBzdHVkZW50IHdpdGggdGhpcyBlbWFpbCBhbHJlYWR5IGV4aXN0cy4nKTtcbiAgfVxuXG4gIGNvbnN0IG5ld1VzZXI6IFVzZXJQcm9maWxlID0ge1xuICAgIGlkOiBgdXNlci0ke0RhdGUubm93KCl9YCxcbiAgICBuYW1lOiBzdHVkZW50RGF0YS5uYW1lLFxuICAgIGVtYWlsOiBzdHVkZW50RGF0YS5lbWFpbCxcbiAgICByb2xlOiAnc3R1ZGVudCcsXG4gICAgY291cnNlOiBzdHVkZW50RGF0YS5jb3Vyc2UsXG4gICAgZW5yb2xsbWVudFllYXI6IHN0dWRlbnREYXRhLmVucm9sbG1lbnRZZWFyLFxuICB9O1xuICBtb2NrVXNlcnNEYi5wdXNoKG5ld1VzZXIpO1xuICByZXR1cm4gbmV3VXNlcjtcbn07XG5cbmV4cG9ydCBjb25zdCB1cGRhdGVTdHVkZW50ID0gYXN5bmMgKFxuICBpZDogc3RyaW5nLFxuICBzdHVkZW50RGF0YTogUGFydGlhbDxTdHVkZW50UmVjb3JkPixcbiAgdG9rZW46IHN0cmluZ1xuKTogUHJvbWlzZTxVc2VyUHJvZmlsZT4gPT4ge1xuICBhd2FpdCBkZWxheSg1MDApO1xuICBpZiAoIXRva2VuLmluY2x1ZGVzKCdhZG1pbicpKSB0aHJvdyBuZXcgRXJyb3IoXCJVbmF1dGhvcml6ZWQgYWNjZXNzXCIpO1xuXG4gIGNvbnN0IHVzZXJJbmRleCA9IG1vY2tVc2Vyc0RiLmZpbmRJbmRleCh1ID0+IHUuaWQgPT09IGlkKTtcbiAgaWYgKHVzZXJJbmRleCA9PT0gLTEpIHRocm93IG5ldyBFcnJvcihcIlVzZXIgbm90IGZvdW5kIGZvciB1cGRhdGVcIik7XG5cbiAgT2JqZWN0LmFzc2lnbihtb2NrVXNlcnNEYlt1c2VySW5kZXhdLCBzdHVkZW50RGF0YSk7XG4gIHJldHVybiBtb2NrVXNlcnNEYlt1c2VySW5kZXhdO1xufTtcblxuZXhwb3J0IGNvbnN0IGRlbGV0ZVN0dWRlbnQgPSBhc3luYyAoaWQ6IHN0cmluZywgdG9rZW46IHN0cmluZyk6IFByb21pc2U8dm9pZD4gPT4ge1xuICBhd2FpdCBkZWxheSg1MDApO1xuICBpZiAoIXRva2VuLmluY2x1ZGVzKCdhZG1pbicpKSB0aHJvdyBuZXcgRXJyb3IoXCJVbmF1dGhvcml6ZWQgYWNjZXNzXCIpO1xuICBtb2NrVXNlcnNEYiA9IG1vY2tVc2Vyc0RiLmZpbHRlcih1ID0+IHUuaWQgIT09IGlkKTtcbn07XG5cbmV4cG9ydCBjb25zdCBjaGFuZ2VVc2VyUm9sZSA9IGFzeW5jIChcbiAgdXNlcklkOiBzdHJpbmcsXG4gIG5ld1JvbGU6ICdhZG1pbicgfCAnc3R1ZGVudCcsXG4gIHRva2VuOiBzdHJpbmdcbik6IFByb21pc2U8VXNlclByb2ZpbGU+ID0+IHtcbiAgYXdhaXQgZGVsYXkoNTAwKTtcbiAgaWYgKCF0b2tlbi5pbmNsdWRlcygnYWRtaW4nKSkgdGhyb3cgbmV3IEVycm9yKFwiVW5hdXRob3JpemVkIGFjY2Vzc1wiKTtcblxuICBjb25zdCB1c2VySW5kZXggPSBtb2NrVXNlcnNEYi5maW5kSW5kZXgodSA9PiB1LmlkID09PSB1c2VySWQpO1xuICBpZiAodXNlckluZGV4ID09PSAtMSkgdGhyb3cgbmV3IEVycm9yKFwiVXNlciBub3QgZm91bmQgZm9yIHJvbGUgY2hhbmdlXCIpO1xuXG4gIG1vY2tVc2Vyc0RiW3VzZXJJbmRleF0ucm9sZSA9IG5ld1JvbGU7XG4gIHJldHVybiBtb2NrVXNlcnNEYlt1c2VySW5kZXhdO1xufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyA9PT0gVVNFUiBQUk9GSUxFICYgREFTSEJPQVJEXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuZXhwb3J0IGNvbnN0IGdldEFkbWluRGFzaGJvYXJkU3RhdHMgPSBhc3luYyAoXG4gIHRva2VuOiBzdHJpbmdcbik6IFByb21pc2U8eyB0b3RhbDogbnVtYmVyOyBhY3RpdmU6IG51bWJlcjsgZ3JhZHVhdGVkOiBudW1iZXIgfT4gPT4ge1xuICBhd2FpdCBkZWxheSg0MDApO1xuICBpZiAoIXRva2VuLmluY2x1ZGVzKCdhZG1pbicpKSB0aHJvdyBuZXcgRXJyb3IoXCJVbmF1dGhvcml6ZWQgYWNjZXNzXCIpO1xuXG4gIGNvbnN0IGFsbFN0dWRlbnRzID0gZ2V0U3R1ZGVudFJlY29yZHMoKTtcbiAgcmV0dXJuIHtcbiAgICB0b3RhbDogYWxsU3R1ZGVudHMubGVuZ3RoLFxuICAgIGFjdGl2ZTogYWxsU3R1ZGVudHMuZmlsdGVyKHMgPT4gcy5zdGF0dXMgPT09ICdBY3RpdmUnKS5sZW5ndGgsXG4gICAgZ3JhZHVhdGVkOiBhbGxTdHVkZW50cy5maWx0ZXIocyA9PiBzLnN0YXR1cyA9PT0gJ0dyYWR1YXRlZCcpLmxlbmd0aCxcbiAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCBnZXRNeVByb2ZpbGUgPSBhc3luYyAodG9rZW46IHN0cmluZyk6IFByb21pc2U8VXNlclByb2ZpbGU+ID0+IHtcbiAgYXdhaXQgZGVsYXkoMzAwKTtcbiAgY29uc3QgdXNlcklkID0gdG9rZW4ucmVwbGFjZSgnbW9jay1qd3QtZm9yLScsICcnKTtcbiAgY29uc3QgdXNlciA9IG1vY2tVc2Vyc0RiLmZpbmQodSA9PiB1LmlkID09PSB1c2VySWQpO1xuICBpZiAoIXVzZXIpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2Vzc2lvbiB0b2tlbi5cIik7XG4gIHJldHVybiB7IC4uLnVzZXIgfTtcbn07XG5cbmV4cG9ydCBjb25zdCB1cGRhdGVNeVByb2ZpbGUgPSBhc3luYyAoXG4gIHByb2ZpbGVEYXRhOiBQYXJ0aWFsPFVzZXJQcm9maWxlPixcbiAgdG9rZW46IHN0cmluZ1xuKTogUHJvbWlzZTxVc2VyUHJvZmlsZT4gPT4ge1xuICBhd2FpdCBkZWxheSg1MDApO1xuICBjb25zdCB1c2VySWQgPSB0b2tlbi5yZXBsYWNlKCdtb2NrLWp3dC1mb3ItJywgJycpO1xuICBjb25zdCB1c2VySW5kZXggPSBtb2NrVXNlcnNEYi5maW5kSW5kZXgodSA9PiB1LmlkID09PSB1c2VySWQpO1xuICBpZiAodXNlckluZGV4ID09PSAtMSkgdGhyb3cgbmV3IEVycm9yKFwiVXNlciBub3QgZm91bmQgdG8gdXBkYXRlIHByb2ZpbGUuXCIpO1xuICBPYmplY3QuYXNzaWduKG1vY2tVc2Vyc0RiW3VzZXJJbmRleF0sIHByb2ZpbGVEYXRhKTtcbiAgcmV0dXJuIHsgLi4ubW9ja1VzZXJzRGJbdXNlckluZGV4XSB9O1xufTtcbiJdLCJuYW1lcyI6WyJheGlvcyIsImRlbGF5IiwibXMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJtb2NrVXNlcnNEYiIsImlkIiwibmFtZSIsImVtYWlsIiwicm9sZSIsInBob25lIiwiY291cnNlIiwiZW5yb2xsbWVudFllYXIiLCJnZXRTdHVkZW50UmVjb3JkcyIsImZpbHRlciIsInVzZXIiLCJtYXAiLCJzdGF0dXMiLCJsb2dpblVzZXIiLCJwYXNzd29yZCIsInJlc3BvbnNlIiwicG9zdCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19CQUNLRU5EX1VSTCIsImRhdGEiLCJlcnJvciIsIm1lc3NhZ2UiLCJFcnJvciIsIkJBU0VfVVJMIiwicmVnaXN0ZXJVc2VyIiwidXNlckRhdGEiLCJ1cmwiLCJjb25zb2xlIiwibG9nIiwicmVzIiwiZnVsbE5hbWUiLCJ3aXRoQ3JlZGVudGlhbHMiLCJnZXRVc2VyUHJvZmlsZSIsInRva2VuIiwidXNlcklkIiwicmVwbGFjZSIsImZpbmQiLCJ1IiwidXBkYXRlVXNlclByb2ZpbGUiLCJwcm9maWxlRGF0YSIsImluY2x1ZGVzIiwidXNlckluZGV4IiwiZmluZEluZGV4IiwiT2JqZWN0IiwiYXNzaWduIiwiZ2V0QWxsU3R1ZGVudHMiLCJvcHRpb25zIiwicGFnZSIsImxpbWl0Iiwic3RhdHVzRmlsdGVyIiwiYWxsU3R1ZGVudHMiLCJzIiwidG90YWwiLCJsZW5ndGgiLCJwYWdpbmF0ZWRTdHVkZW50cyIsInNsaWNlIiwic3R1ZGVudHMiLCJjcmVhdGVTdHVkZW50Iiwic3R1ZGVudERhdGEiLCJzb21lIiwibmV3VXNlciIsIkRhdGUiLCJub3ciLCJwdXNoIiwidXBkYXRlU3R1ZGVudCIsImRlbGV0ZVN0dWRlbnQiLCJjaGFuZ2VVc2VyUm9sZSIsIm5ld1JvbGUiLCJnZXRBZG1pbkRhc2hib2FyZFN0YXRzIiwiYWN0aXZlIiwiZ3JhZHVhdGVkIiwiZ2V0TXlQcm9maWxlIiwidXBkYXRlTXlQcm9maWxlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/api.ts\n"));

/***/ })

});