"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(auth)/register/page",{

/***/ "(app-pages-browser)/./src/lib/api.ts":
/*!************************!*\
  !*** ./src/lib/api.ts ***!
  \************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   changeUserRole: () => (/* binding */ changeUserRole),\n/* harmony export */   createStudent: () => (/* binding */ createStudent),\n/* harmony export */   deleteStudent: () => (/* binding */ deleteStudent),\n/* harmony export */   getAdminDashboardStats: () => (/* binding */ getAdminDashboardStats),\n/* harmony export */   getAllStudents: () => (/* binding */ getAllStudents),\n/* harmony export */   getMyProfile: () => (/* binding */ getMyProfile),\n/* harmony export */   getUserProfile: () => (/* binding */ getUserProfile),\n/* harmony export */   loginUser: () => (/* binding */ loginUser),\n/* harmony export */   registerUser: () => (/* binding */ registerUser),\n/* harmony export */   updateMyProfile: () => (/* binding */ updateMyProfile),\n/* harmony export */   updateStudent: () => (/* binding */ updateStudent),\n/* harmony export */   updateUserProfile: () => (/* binding */ updateUserProfile)\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/../node_modules/axios/lib/axios.js\");\n\n// Simulate network delay for realism\nconst delay = (ms)=>new Promise((resolve)=>setTimeout(resolve, ms));\n// =====================================\n// === MOCKED DATABASE (SOURCE OF TRUTH)\n// =====================================\nlet mockUsersDb = [\n    {\n        id: 'admin-01',\n        name: 'Admin User',\n        email: 'admin@test.com',\n        role: 'admin',\n        phone: '123-456-7890'\n    },\n    {\n        id: 'student-01',\n        name: 'Student User',\n        email: 'student@test.com',\n        role: 'student',\n        phone: '098-765-4321',\n        course: 'Computer Science',\n        enrollmentYear: 2022\n    },\n    {\n        id: 's1',\n        name: 'Alice Johnson',\n        email: 'alice@test.com',\n        role: 'student',\n        phone: '111-222-3333',\n        course: 'Web Development',\n        enrollmentYear: 2023\n    },\n    {\n        id: 's2',\n        name: 'Bob Williams',\n        email: 'bob@test.com',\n        role: 'student',\n        phone: '444-555-6666',\n        course: 'Data Science',\n        enrollmentYear: 2022\n    },\n    {\n        id: 's3',\n        name: 'Charlie Brown',\n        email: 'charlie@test.com',\n        role: 'student',\n        phone: '777-888-9999',\n        course: 'UX/UI Design',\n        enrollmentYear: 2023\n    },\n    {\n        id: 's4',\n        name: 'Diana Prince',\n        email: 'diana@test.com',\n        role: 'student',\n        phone: '121-232-3434',\n        course: 'Data Science',\n        enrollmentYear: 2024\n    }\n];\n// ============================================\n// === UTILITY FUNCTION: StudentRecord Mapping\n// ============================================\nconst getStudentRecords = ()=>{\n    return mockUsersDb.filter((user)=>user.role === 'student').map((user)=>({\n            id: user.id,\n            name: user.name,\n            email: user.email,\n            course: user.course || 'N/A',\n            enrollmentYear: user.enrollmentYear || 0,\n            status: user.enrollmentYear && user.enrollmentYear < 2023 ? 'Graduated' : 'Active'\n        }));\n};\n// ==============================\n// === AUTHENTICATION\n// ==============================\n// === LOGIN USER\n/**\n * Logs in a user by sending their credentials to the backend.\n * On success, returns a user profile and JWT token.\n */ const loginUser = async (email, password)=>{\n    try {\n        const response = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].post(\"\".concat(\"http://localhost:5001\", \"/api/auth/login\"), {\n            email,\n            password\n        });\n        const { user, token } = response.data;\n        // Map backend's fullName to frontend's expected 'name'\n        const formattedUser = {\n            id: user.id,\n            name: user.fullName,\n            email: user.email,\n            role: user.role,\n            phone: user.phone,\n            profilePicture: user.profilePicture,\n            course: user.course,\n            enrollmentYear: user.enrollmentYear,\n            joinedAt: user.joinedAt || user.createdAt\n        };\n        return {\n            user: formattedUser,\n            token\n        };\n    } catch (error) {\n        var _error_response_data, _error_response;\n        const message = (error === null || error === void 0 ? void 0 : (_error_response = error.response) === null || _error_response === void 0 ? void 0 : (_error_response_data = _error_response.data) === null || _error_response_data === void 0 ? void 0 : _error_response_data.message) || 'Login failed';\n        throw new Error(message);\n    }\n};\n// === REGISTER USER\nconst BASE_URL = \"http://localhost:5001\";\nconst registerUser = async (userData)=>{\n    try {\n        const url = \"\".concat(BASE_URL, \"/api/auth/register\");\n        console.log(\"ðŸ‘‰ Full Registration URL:\", url); // ðŸ‘ˆ print this!\n        const res = await axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].post(url, {\n            fullName: userData.name,\n            email: userData.email,\n            password: userData.password,\n            phone: userData.phone,\n            course: userData.course\n        }, {\n            withCredentials: true\n        });\n        return res.data.user;\n    } catch (error) {\n        var _error_response_data, _error_response;\n        console.error(\"Registration error:\", error); // ðŸ‘ˆ log entire error\n        throw new Error((error === null || error === void 0 ? void 0 : (_error_response = error.response) === null || _error_response === void 0 ? void 0 : (_error_response_data = _error_response.data) === null || _error_response_data === void 0 ? void 0 : _error_response_data.message) || 'Registration failed. Please try again.');\n    }\n};\n// === THE USER\nconst getUserProfile = async (token)=>{\n    await delay(300);\n    const userId = token.replace('mock-jwt-for-', '');\n    const user = mockUsersDb.find((u)=>u.id === userId);\n    if (!user) throw new Error(\"User not found\");\n    return user;\n};\nconst updateUserProfile = async (userId, profileData, token)=>{\n    await delay(500);\n    if (!token.includes('mock-jwt-for-')) throw new Error(\"Unauthorized access\");\n    const userIndex = mockUsersDb.findIndex((u)=>u.id === userId);\n    if (userIndex === -1) throw new Error(\"User not found for update\");\n    Object.assign(mockUsersDb[userIndex], profileData);\n    return mockUsersDb[userIndex];\n};\nconst getAllStudents = async function(token) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    await delay(800);\n    if (!token.includes('admin')) throw new Error(\"Unauthorized access\");\n    const { page = 1, limit = 5, statusFilter = 'All' } = options;\n    let allStudents = getStudentRecords();\n    if (statusFilter !== 'All') {\n        allStudents = allStudents.filter((s)=>s.status === statusFilter);\n    }\n    const total = allStudents.length;\n    const paginatedStudents = allStudents.slice((page - 1) * limit, page * limit);\n    return {\n        students: paginatedStudents,\n        total\n    };\n};\nconst createStudent = async (studentData, token)=>{\n    await delay(500);\n    if (!token.includes('admin')) throw new Error(\"Unauthorized access\");\n    if (mockUsersDb.some((user)=>user.email === studentData.email)) {\n        throw new Error('A student with this email already exists.');\n    }\n    const newUser = {\n        id: \"user-\".concat(Date.now()),\n        name: studentData.name,\n        email: studentData.email,\n        role: 'student',\n        course: studentData.course,\n        enrollmentYear: studentData.enrollmentYear\n    };\n    mockUsersDb.push(newUser);\n    return newUser;\n};\nconst updateStudent = async (id, studentData, token)=>{\n    await delay(500);\n    if (!token.includes('admin')) throw new Error(\"Unauthorized access\");\n    const userIndex = mockUsersDb.findIndex((u)=>u.id === id);\n    if (userIndex === -1) throw new Error(\"User not found for update\");\n    Object.assign(mockUsersDb[userIndex], studentData);\n    return mockUsersDb[userIndex];\n};\nconst deleteStudent = async (id, token)=>{\n    await delay(500);\n    if (!token.includes('admin')) throw new Error(\"Unauthorized access\");\n    mockUsersDb = mockUsersDb.filter((u)=>u.id !== id);\n};\nconst changeUserRole = async (userId, newRole, token)=>{\n    await delay(500);\n    if (!token.includes('admin')) throw new Error(\"Unauthorized access\");\n    const userIndex = mockUsersDb.findIndex((u)=>u.id === userId);\n    if (userIndex === -1) throw new Error(\"User not found for role change\");\n    mockUsersDb[userIndex].role = newRole;\n    return mockUsersDb[userIndex];\n};\n// ==============================\n// === USER PROFILE & DASHBOARD\n// ==============================\nconst getAdminDashboardStats = async (token)=>{\n    await delay(400);\n    if (!token.includes('admin')) throw new Error(\"Unauthorized access\");\n    const allStudents = getStudentRecords();\n    return {\n        total: allStudents.length,\n        active: allStudents.filter((s)=>s.status === 'Active').length,\n        graduated: allStudents.filter((s)=>s.status === 'Graduated').length\n    };\n};\nconst getMyProfile = async (token)=>{\n    await delay(300);\n    const userId = token.replace('mock-jwt-for-', '');\n    const user = mockUsersDb.find((u)=>u.id === userId);\n    if (!user) throw new Error(\"Invalid session token.\");\n    return {\n        ...user\n    };\n};\nconst updateMyProfile = async (profileData, token)=>{\n    await delay(500);\n    const userId = token.replace('mock-jwt-for-', '');\n    const userIndex = mockUsersDb.findIndex((u)=>u.id === userId);\n    if (userIndex === -1) throw new Error(\"User not found to update profile.\");\n    Object.assign(mockUsersDb[userIndex], profileData);\n    return {\n        ...mockUsersDb[userIndex]\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QyxpQkFBaUI7SUFDOUMsTUFBTU0sWUFBWTlDLFlBQVkrQyxTQUFTLENBQUNMLENBQUFBLElBQUtBLEVBQUV6QyxFQUFFLEtBQUtzQztJQUN0RCxJQUFJTyxjQUFjLENBQUMsR0FBRyxNQUFNLElBQUlqQixNQUFNO0lBQ3RDbUIsT0FBT0MsTUFBTSxDQUFDakQsV0FBVyxDQUFDOEMsVUFBVSxFQUFFRjtJQUN0QyxPQUFPO1FBQUUsR0FBRzVDLFdBQVcsQ0FBQzhDLFVBQVU7SUFBQztBQUNyQyxFQUFFIiwic291cmNlcyI6WyIvVXNlcnMveW91bmdzYXZhZ2Uvc3R1ZGVudC1tYW5hZ2VtZW50LXN5c3RlbS0vZnJvbnRlbmQvc3JjL2xpYi9hcGkudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXV0aFJlc3BvbnNlLCBTdHVkZW50UmVjb3JkLCBVc2VyUHJvZmlsZSB9IGZyb20gXCJAL3R5cGVzXCI7XG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xuXG4vLyBTaW11bGF0ZSBuZXR3b3JrIGRlbGF5IGZvciByZWFsaXNtXG5jb25zdCBkZWxheSA9IChtczogbnVtYmVyKSA9PiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpKTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gPT09IE1PQ0tFRCBEQVRBQkFTRSAoU09VUkNFIE9GIFRSVVRIKVxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5sZXQgbW9ja1VzZXJzRGI6IFVzZXJQcm9maWxlW10gPSBbXG4gIHsgaWQ6ICdhZG1pbi0wMScsIG5hbWU6ICdBZG1pbiBVc2VyJywgZW1haWw6ICdhZG1pbkB0ZXN0LmNvbScsIHJvbGU6ICdhZG1pbicsIHBob25lOiAnMTIzLTQ1Ni03ODkwJyB9LFxuICB7IGlkOiAnc3R1ZGVudC0wMScsIG5hbWU6ICdTdHVkZW50IFVzZXInLCBlbWFpbDogJ3N0dWRlbnRAdGVzdC5jb20nLCByb2xlOiAnc3R1ZGVudCcsIHBob25lOiAnMDk4LTc2NS00MzIxJywgY291cnNlOiAnQ29tcHV0ZXIgU2NpZW5jZScsIGVucm9sbG1lbnRZZWFyOiAyMDIyIH0sXG4gIHsgaWQ6ICdzMScsIG5hbWU6ICdBbGljZSBKb2huc29uJywgZW1haWw6ICdhbGljZUB0ZXN0LmNvbScsIHJvbGU6ICdzdHVkZW50JywgcGhvbmU6ICcxMTEtMjIyLTMzMzMnLCBjb3Vyc2U6ICdXZWIgRGV2ZWxvcG1lbnQnLCBlbnJvbGxtZW50WWVhcjogMjAyMyB9LFxuICB7IGlkOiAnczInLCBuYW1lOiAnQm9iIFdpbGxpYW1zJywgZW1haWw6ICdib2JAdGVzdC5jb20nLCByb2xlOiAnc3R1ZGVudCcsIHBob25lOiAnNDQ0LTU1NS02NjY2JywgY291cnNlOiAnRGF0YSBTY2llbmNlJywgZW5yb2xsbWVudFllYXI6IDIwMjIgfSxcbiAgeyBpZDogJ3MzJywgbmFtZTogJ0NoYXJsaWUgQnJvd24nLCBlbWFpbDogJ2NoYXJsaWVAdGVzdC5jb20nLCByb2xlOiAnc3R1ZGVudCcsIHBob25lOiAnNzc3LTg4OC05OTk5JywgY291cnNlOiAnVVgvVUkgRGVzaWduJywgZW5yb2xsbWVudFllYXI6IDIwMjMgfSxcbiAgeyBpZDogJ3M0JywgbmFtZTogJ0RpYW5hIFByaW5jZScsIGVtYWlsOiAnZGlhbmFAdGVzdC5jb20nLCByb2xlOiAnc3R1ZGVudCcsIHBob25lOiAnMTIxLTIzMi0zNDM0JywgY291cnNlOiAnRGF0YSBTY2llbmNlJywgZW5yb2xsbWVudFllYXI6IDIwMjQgfSxcbl07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyA9PT0gVVRJTElUWSBGVU5DVElPTjogU3R1ZGVudFJlY29yZCBNYXBwaW5nXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5jb25zdCBnZXRTdHVkZW50UmVjb3JkcyA9ICgpOiBTdHVkZW50UmVjb3JkW10gPT4ge1xuICByZXR1cm4gbW9ja1VzZXJzRGJcbiAgICAuZmlsdGVyKHVzZXIgPT4gdXNlci5yb2xlID09PSAnc3R1ZGVudCcpXG4gICAgLm1hcCh1c2VyID0+ICh7XG4gICAgICBpZDogdXNlci5pZCxcbiAgICAgIG5hbWU6IHVzZXIubmFtZSxcbiAgICAgIGVtYWlsOiB1c2VyLmVtYWlsLFxuICAgICAgY291cnNlOiB1c2VyLmNvdXJzZSB8fCAnTi9BJyxcbiAgICAgIGVucm9sbG1lbnRZZWFyOiB1c2VyLmVucm9sbG1lbnRZZWFyIHx8IDAsXG4gICAgICBzdGF0dXM6ICh1c2VyLmVucm9sbG1lbnRZZWFyICYmIHVzZXIuZW5yb2xsbWVudFllYXIgPCAyMDIzKSA/ICdHcmFkdWF0ZWQnIDogJ0FjdGl2ZScsXG4gICAgfSkpO1xufTtcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyA9PT0gQVVUSEVOVElDQVRJT05cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vLyA9PT0gTE9HSU4gVVNFUlxuXG4vKipcbiAqIExvZ3MgaW4gYSB1c2VyIGJ5IHNlbmRpbmcgdGhlaXIgY3JlZGVudGlhbHMgdG8gdGhlIGJhY2tlbmQuXG4gKiBPbiBzdWNjZXNzLCByZXR1cm5zIGEgdXNlciBwcm9maWxlIGFuZCBKV1QgdG9rZW4uXG4gKi9cbmV4cG9ydCBjb25zdCBsb2dpblVzZXIgPSBhc3luYyAoZW1haWw6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZyk6IFByb21pc2U8QXV0aFJlc3BvbnNlPiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5wb3N0KGAke3Byb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0JBQ0tFTkRfVVJMfS9hcGkvYXV0aC9sb2dpbmAsIHtcbiAgICAgIGVtYWlsLFxuICAgICAgcGFzc3dvcmQsXG4gICAgfSk7XG5cbiAgICBjb25zdCB7IHVzZXIsIHRva2VuIH0gPSByZXNwb25zZS5kYXRhO1xuXG4gICAgLy8gTWFwIGJhY2tlbmQncyBmdWxsTmFtZSB0byBmcm9udGVuZCdzIGV4cGVjdGVkICduYW1lJ1xuICAgIGNvbnN0IGZvcm1hdHRlZFVzZXI6IFVzZXJQcm9maWxlID0ge1xuICAgICAgaWQ6IHVzZXIuaWQsXG4gICAgICBuYW1lOiB1c2VyLmZ1bGxOYW1lLFxuICAgICAgZW1haWw6IHVzZXIuZW1haWwsXG4gICAgICByb2xlOiB1c2VyLnJvbGUsXG4gICAgICBwaG9uZTogdXNlci5waG9uZSxcbiAgICAgIHByb2ZpbGVQaWN0dXJlOiB1c2VyLnByb2ZpbGVQaWN0dXJlLFxuICAgICAgY291cnNlOiB1c2VyLmNvdXJzZSxcbiAgICAgIGVucm9sbG1lbnRZZWFyOiB1c2VyLmVucm9sbG1lbnRZZWFyLFxuICAgICAgam9pbmVkQXQ6IHVzZXIuam9pbmVkQXQgfHwgdXNlci5jcmVhdGVkQXQsIC8vIHN1cHBvcnQgYm90aCBpZiBuZWVkZWRcbiAgICB9O1xuXG4gICAgcmV0dXJuIHsgdXNlcjogZm9ybWF0dGVkVXNlciwgdG9rZW4gfTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnJvcj8ucmVzcG9uc2U/LmRhdGE/Lm1lc3NhZ2UgfHwgJ0xvZ2luIGZhaWxlZCc7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59O1xuXG4vLyA9PT0gUkVHSVNURVIgVVNFUlxuY29uc3QgQkFTRV9VUkwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19CQUNLRU5EX1VSTDtcblxuZXhwb3J0IGNvbnN0IHJlZ2lzdGVyVXNlciA9IGFzeW5jICh1c2VyRGF0YToge1xuICBuYW1lOiBzdHJpbmc7XG4gIGVtYWlsOiBzdHJpbmc7XG4gIHBhc3N3b3JkOiBzdHJpbmc7XG4gIHBob25lPzogc3RyaW5nO1xuICBjb3Vyc2U/OiBzdHJpbmc7XG59KSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgdXJsID0gYCR7QkFTRV9VUkx9L2FwaS9hdXRoL3JlZ2lzdGVyYDtcbiAgICBjb25zb2xlLmxvZyhcIvCfkYkgRnVsbCBSZWdpc3RyYXRpb24gVVJMOlwiLCB1cmwpOyAvLyDwn5GIIHByaW50IHRoaXMhXG5cbiAgICBjb25zdCByZXMgPSBhd2FpdCBheGlvcy5wb3N0KHVybCwge1xuICAgICAgZnVsbE5hbWU6IHVzZXJEYXRhLm5hbWUsXG4gICAgICBlbWFpbDogdXNlckRhdGEuZW1haWwsXG4gICAgICBwYXNzd29yZDogdXNlckRhdGEucGFzc3dvcmQsXG4gICAgICBwaG9uZTogdXNlckRhdGEucGhvbmUsXG4gICAgICBjb3Vyc2U6IHVzZXJEYXRhLmNvdXJzZSxcbiAgICB9LCB7ICBcbiAgICAgIHdpdGhDcmVkZW50aWFsczogdHJ1ZSxcbiAgICB9KTtcblxuICAgIHJldHVybiByZXMuZGF0YS51c2VyO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcihcIlJlZ2lzdHJhdGlvbiBlcnJvcjpcIiwgZXJyb3IpOyAvLyDwn5GIIGxvZyBlbnRpcmUgZXJyb3JcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBlcnJvcj8ucmVzcG9uc2U/LmRhdGE/Lm1lc3NhZ2UgfHwgJ1JlZ2lzdHJhdGlvbiBmYWlsZWQuIFBsZWFzZSB0cnkgYWdhaW4uJ1xuICAgICk7XG4gIH1cbn07XG5cbi8vID09PSBUSEUgVVNFUlxuXG5leHBvcnQgY29uc3QgZ2V0VXNlclByb2ZpbGUgPSBhc3luYyAodG9rZW46IHN0cmluZyk6IFByb21pc2U8VXNlclByb2ZpbGU+ID0+IHtcbiAgYXdhaXQgZGVsYXkoMzAwKTtcbiAgY29uc3QgdXNlcklkID0gdG9rZW4ucmVwbGFjZSgnbW9jay1qd3QtZm9yLScsICcnKTtcbiAgY29uc3QgdXNlciA9IG1vY2tVc2Vyc0RiLmZpbmQodSA9PiB1LmlkID09PSB1c2VySWQpO1xuICBpZiAoIXVzZXIpIHRocm93IG5ldyBFcnJvcihcIlVzZXIgbm90IGZvdW5kXCIpO1xuICByZXR1cm4gdXNlcjtcbn07XG5leHBvcnQgY29uc3QgdXBkYXRlVXNlclByb2ZpbGUgPSBhc3luYyAoXG4gIHVzZXJJZDogc3RyaW5nLFxuICBwcm9maWxlRGF0YTogUGFydGlhbDxVc2VyUHJvZmlsZT4sXG4gIHRva2VuOiBzdHJpbmdcbik6IFByb21pc2U8VXNlclByb2ZpbGU+ID0+IHtcbiAgYXdhaXQgZGVsYXkoNTAwKTtcbiAgaWYgKCF0b2tlbi5pbmNsdWRlcygnbW9jay1qd3QtZm9yLScpKSB0aHJvdyBuZXcgRXJyb3IoXCJVbmF1dGhvcml6ZWQgYWNjZXNzXCIpO1xuXG4gIGNvbnN0IHVzZXJJbmRleCA9IG1vY2tVc2Vyc0RiLmZpbmRJbmRleCh1ID0+IHUuaWQgPT09IHVzZXJJZCk7XG4gIGlmICh1c2VySW5kZXggPT09IC0xKSB0aHJvdyBuZXcgRXJyb3IoXCJVc2VyIG5vdCBmb3VuZCBmb3IgdXBkYXRlXCIpO1xuXG4gIE9iamVjdC5hc3NpZ24obW9ja1VzZXJzRGJbdXNlckluZGV4XSwgcHJvZmlsZURhdGEpO1xuICByZXR1cm4gbW9ja1VzZXJzRGJbdXNlckluZGV4XTtcbn07XG5cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyA9PT0gU1RVREVOVCBNQU5BR0VNRU5UIChBRE1JTilcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5pbnRlcmZhY2UgR2V0QWxsU3R1ZGVudHNPcHRpb25zIHtcbiAgcGFnZT86IG51bWJlcjtcbiAgbGltaXQ/OiBudW1iZXI7XG4gIHN0YXR1c0ZpbHRlcj86ICdBbGwnIHwgJ0FjdGl2ZScgfCAnR3JhZHVhdGVkJyB8ICdEcm9wcGVkJztcbn1cblxuZXhwb3J0IGNvbnN0IGdldEFsbFN0dWRlbnRzID0gYXN5bmMgKFxuICB0b2tlbjogc3RyaW5nLFxuICBvcHRpb25zOiBHZXRBbGxTdHVkZW50c09wdGlvbnMgPSB7fVxuKTogUHJvbWlzZTx7IHN0dWRlbnRzOiBTdHVkZW50UmVjb3JkW107IHRvdGFsOiBudW1iZXIgfT4gPT4ge1xuICBhd2FpdCBkZWxheSg4MDApO1xuICBpZiAoIXRva2VuLmluY2x1ZGVzKCdhZG1pbicpKSB0aHJvdyBuZXcgRXJyb3IoXCJVbmF1dGhvcml6ZWQgYWNjZXNzXCIpO1xuXG4gIGNvbnN0IHsgcGFnZSA9IDEsIGxpbWl0ID0gNSwgc3RhdHVzRmlsdGVyID0gJ0FsbCcgfSA9IG9wdGlvbnM7XG4gIGxldCBhbGxTdHVkZW50cyA9IGdldFN0dWRlbnRSZWNvcmRzKCk7XG5cbiAgaWYgKHN0YXR1c0ZpbHRlciAhPT0gJ0FsbCcpIHtcbiAgICBhbGxTdHVkZW50cyA9IGFsbFN0dWRlbnRzLmZpbHRlcihzID0+IHMuc3RhdHVzID09PSBzdGF0dXNGaWx0ZXIpO1xuICB9XG5cbiAgY29uc3QgdG90YWwgPSBhbGxTdHVkZW50cy5sZW5ndGg7XG4gIGNvbnN0IHBhZ2luYXRlZFN0dWRlbnRzID0gYWxsU3R1ZGVudHMuc2xpY2UoKHBhZ2UgLSAxKSAqIGxpbWl0LCBwYWdlICogbGltaXQpO1xuICByZXR1cm4geyBzdHVkZW50czogcGFnaW5hdGVkU3R1ZGVudHMsIHRvdGFsIH07XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlU3R1ZGVudCA9IGFzeW5jIChcbiAgc3R1ZGVudERhdGE6IE9taXQ8U3R1ZGVudFJlY29yZCwgJ2lkJz4sXG4gIHRva2VuOiBzdHJpbmdcbik6IFByb21pc2U8VXNlclByb2ZpbGU+ID0+IHtcbiAgYXdhaXQgZGVsYXkoNTAwKTtcbiAgaWYgKCF0b2tlbi5pbmNsdWRlcygnYWRtaW4nKSkgdGhyb3cgbmV3IEVycm9yKFwiVW5hdXRob3JpemVkIGFjY2Vzc1wiKTtcbiAgaWYgKG1vY2tVc2Vyc0RiLnNvbWUodXNlciA9PiB1c2VyLmVtYWlsID09PSBzdHVkZW50RGF0YS5lbWFpbCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Egc3R1ZGVudCB3aXRoIHRoaXMgZW1haWwgYWxyZWFkeSBleGlzdHMuJyk7XG4gIH1cblxuICBjb25zdCBuZXdVc2VyOiBVc2VyUHJvZmlsZSA9IHtcbiAgICBpZDogYHVzZXItJHtEYXRlLm5vdygpfWAsXG4gICAgbmFtZTogc3R1ZGVudERhdGEubmFtZSxcbiAgICBlbWFpbDogc3R1ZGVudERhdGEuZW1haWwsXG4gICAgcm9sZTogJ3N0dWRlbnQnLFxuICAgIGNvdXJzZTogc3R1ZGVudERhdGEuY291cnNlLFxuICAgIGVucm9sbG1lbnRZZWFyOiBzdHVkZW50RGF0YS5lbnJvbGxtZW50WWVhcixcbiAgfTtcbiAgbW9ja1VzZXJzRGIucHVzaChuZXdVc2VyKTtcbiAgcmV0dXJuIG5ld1VzZXI7XG59O1xuXG5leHBvcnQgY29uc3QgdXBkYXRlU3R1ZGVudCA9IGFzeW5jIChcbiAgaWQ6IHN0cmluZyxcbiAgc3R1ZGVudERhdGE6IFBhcnRpYWw8U3R1ZGVudFJlY29yZD4sXG4gIHRva2VuOiBzdHJpbmdcbik6IFByb21pc2U8VXNlclByb2ZpbGU+ID0+IHtcbiAgYXdhaXQgZGVsYXkoNTAwKTtcbiAgaWYgKCF0b2tlbi5pbmNsdWRlcygnYWRtaW4nKSkgdGhyb3cgbmV3IEVycm9yKFwiVW5hdXRob3JpemVkIGFjY2Vzc1wiKTtcblxuICBjb25zdCB1c2VySW5kZXggPSBtb2NrVXNlcnNEYi5maW5kSW5kZXgodSA9PiB1LmlkID09PSBpZCk7XG4gIGlmICh1c2VySW5kZXggPT09IC0xKSB0aHJvdyBuZXcgRXJyb3IoXCJVc2VyIG5vdCBmb3VuZCBmb3IgdXBkYXRlXCIpO1xuXG4gIE9iamVjdC5hc3NpZ24obW9ja1VzZXJzRGJbdXNlckluZGV4XSwgc3R1ZGVudERhdGEpO1xuICByZXR1cm4gbW9ja1VzZXJzRGJbdXNlckluZGV4XTtcbn07XG5cbmV4cG9ydCBjb25zdCBkZWxldGVTdHVkZW50ID0gYXN5bmMgKGlkOiBzdHJpbmcsIHRva2VuOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgYXdhaXQgZGVsYXkoNTAwKTtcbiAgaWYgKCF0b2tlbi5pbmNsdWRlcygnYWRtaW4nKSkgdGhyb3cgbmV3IEVycm9yKFwiVW5hdXRob3JpemVkIGFjY2Vzc1wiKTtcbiAgbW9ja1VzZXJzRGIgPSBtb2NrVXNlcnNEYi5maWx0ZXIodSA9PiB1LmlkICE9PSBpZCk7XG59O1xuXG5leHBvcnQgY29uc3QgY2hhbmdlVXNlclJvbGUgPSBhc3luYyAoXG4gIHVzZXJJZDogc3RyaW5nLFxuICBuZXdSb2xlOiAnYWRtaW4nIHwgJ3N0dWRlbnQnLFxuICB0b2tlbjogc3RyaW5nXG4pOiBQcm9taXNlPFVzZXJQcm9maWxlPiA9PiB7XG4gIGF3YWl0IGRlbGF5KDUwMCk7XG4gIGlmICghdG9rZW4uaW5jbHVkZXMoJ2FkbWluJykpIHRocm93IG5ldyBFcnJvcihcIlVuYXV0aG9yaXplZCBhY2Nlc3NcIik7XG5cbiAgY29uc3QgdXNlckluZGV4ID0gbW9ja1VzZXJzRGIuZmluZEluZGV4KHUgPT4gdS5pZCA9PT0gdXNlcklkKTtcbiAgaWYgKHVzZXJJbmRleCA9PT0gLTEpIHRocm93IG5ldyBFcnJvcihcIlVzZXIgbm90IGZvdW5kIGZvciByb2xlIGNoYW5nZVwiKTtcblxuICBtb2NrVXNlcnNEYlt1c2VySW5kZXhdLnJvbGUgPSBuZXdSb2xlO1xuICByZXR1cm4gbW9ja1VzZXJzRGJbdXNlckluZGV4XTtcbn07XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gPT09IFVTRVIgUFJPRklMRSAmIERBU0hCT0FSRFxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbmV4cG9ydCBjb25zdCBnZXRBZG1pbkRhc2hib2FyZFN0YXRzID0gYXN5bmMgKFxuICB0b2tlbjogc3RyaW5nXG4pOiBQcm9taXNlPHsgdG90YWw6IG51bWJlcjsgYWN0aXZlOiBudW1iZXI7IGdyYWR1YXRlZDogbnVtYmVyIH0+ID0+IHtcbiAgYXdhaXQgZGVsYXkoNDAwKTtcbiAgaWYgKCF0b2tlbi5pbmNsdWRlcygnYWRtaW4nKSkgdGhyb3cgbmV3IEVycm9yKFwiVW5hdXRob3JpemVkIGFjY2Vzc1wiKTtcblxuICBjb25zdCBhbGxTdHVkZW50cyA9IGdldFN0dWRlbnRSZWNvcmRzKCk7XG4gIHJldHVybiB7XG4gICAgdG90YWw6IGFsbFN0dWRlbnRzLmxlbmd0aCxcbiAgICBhY3RpdmU6IGFsbFN0dWRlbnRzLmZpbHRlcihzID0+IHMuc3RhdHVzID09PSAnQWN0aXZlJykubGVuZ3RoLFxuICAgIGdyYWR1YXRlZDogYWxsU3R1ZGVudHMuZmlsdGVyKHMgPT4gcy5zdGF0dXMgPT09ICdHcmFkdWF0ZWQnKS5sZW5ndGgsXG4gIH07XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0TXlQcm9maWxlID0gYXN5bmMgKHRva2VuOiBzdHJpbmcpOiBQcm9taXNlPFVzZXJQcm9maWxlPiA9PiB7XG4gIGF3YWl0IGRlbGF5KDMwMCk7XG4gIGNvbnN0IHVzZXJJZCA9IHRva2VuLnJlcGxhY2UoJ21vY2stand0LWZvci0nLCAnJyk7XG4gIGNvbnN0IHVzZXIgPSBtb2NrVXNlcnNEYi5maW5kKHUgPT4gdS5pZCA9PT0gdXNlcklkKTtcbiAgaWYgKCF1c2VyKSB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlc3Npb24gdG9rZW4uXCIpO1xuICByZXR1cm4geyAuLi51c2VyIH07XG59O1xuXG5leHBvcnQgY29uc3QgdXBkYXRlTXlQcm9maWxlID0gYXN5bmMgKFxuICBwcm9maWxlRGF0YTogUGFydGlhbDxVc2VyUHJvZmlsZT4sXG4gIHRva2VuOiBzdHJpbmdcbik6IFByb21pc2U8VXNlclByb2ZpbGU+ID0+IHtcbiAgYXdhaXQgZGVsYXkoNTAwKTtcbiAgY29uc3QgdXNlcklkID0gdG9rZW4ucmVwbGFjZSgnbW9jay1qd3QtZm9yLScsICcnKTtcbiAgY29uc3QgdXNlckluZGV4ID0gbW9ja1VzZXJzRGIuZmluZEluZGV4KHUgPT4gdS5pZCA9PT0gdXNlcklkKTtcbiAgaWYgKHVzZXJJbmRleCA9PT0gLTEpIHRocm93IG5ldyBFcnJvcihcIlVzZXIgbm90IGZvdW5kIHRvIHVwZGF0ZSBwcm9maWxlLlwiKTtcbiAgT2JqZWN0LmFzc2lnbihtb2NrVXNlcnNEYlt1c2VySW5kZXhdLCBwcm9maWxlRGF0YSk7XG4gIHJldHVybiB7IC4uLm1vY2tVc2Vyc0RiW3VzZXJJbmRleF0gfTtcbn07XG4iXSwibmFtZXMiOlsiYXhpb3MiLCJkZWxheSIsIm1zIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwibW9ja1VzZXJzRGIiLCJpZCIsIm5hbWUiLCJlbWFpbCIsInJvbGUiLCJwaG9uZSIsImNvdXJzZSIsImVucm9sbG1lbnRZZWFyIiwiZ2V0U3R1ZGVudFJlY29yZHMiLCJmaWx0ZXIiLCJ1c2VyIiwibWFwIiwic3RhdHVzIiwibG9naW5Vc2VyIiwicGFzc3dvcmQiLCJyZXNwb25zZSIsInBvc3QiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQkFDS0VORF9VUkwiLCJ0b2tlbiIsImRhdGEiLCJmb3JtYXR0ZWRVc2VyIiwiZnVsbE5hbWUiLCJwcm9maWxlUGljdHVyZSIsImpvaW5lZEF0IiwiY3JlYXRlZEF0IiwiZXJyb3IiLCJtZXNzYWdlIiwiRXJyb3IiLCJCQVNFX1VSTCIsInJlZ2lzdGVyVXNlciIsInVzZXJEYXRhIiwidXJsIiwiY29uc29sZSIsImxvZyIsInJlcyIsIndpdGhDcmVkZW50aWFscyIsImdldFVzZXJQcm9maWxlIiwidXNlcklkIiwicmVwbGFjZSIsImZpbmQiLCJ1IiwidXBkYXRlVXNlclByb2ZpbGUiLCJwcm9maWxlRGF0YSIsImluY2x1ZGVzIiwidXNlckluZGV4IiwiZmluZEluZGV4IiwiT2JqZWN0IiwiYXNzaWduIiwiZ2V0QWxsU3R1ZGVudHMiLCJvcHRpb25zIiwicGFnZSIsImxpbWl0Iiwic3RhdHVzRmlsdGVyIiwiYWxsU3R1ZGVudHMiLCJzIiwidG90YWwiLCJsZW5ndGgiLCJwYWdpbmF0ZWRTdHVkZW50cyIsInNsaWNlIiwic3R1ZGVudHMiLCJjcmVhdGVTdHVkZW50Iiwic3R1ZGVudERhdGEiLCJzb21lIiwibmV3VXNlciIsIkRhdGUiLCJub3ciLCJwdXNoIiwidXBkYXRlU3R1ZGVudCIsImRlbGV0ZVN0dWRlbnQiLCJjaGFuZ2VVc2VyUm9sZSIsIm5ld1JvbGUiLCJnZXRBZG1pbkRhc2hib2FyZFN0YXRzIiwiYWN0aXZlIiwiZ3JhZHVhdGVkIiwiZ2V0TXlQcm9maWxlIiwidXBkYXRlTXlQcm9maWxlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/api.ts\n"));

/***/ })

});